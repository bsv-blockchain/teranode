package model

import (
	"context"
	"os"
	"runtime"
	"runtime/pprof"
	"testing"
	"time"

	"github.com/bitcoin-sv/ubsv/stores/txmeta"
	"github.com/bitcoin-sv/ubsv/stores/txmeta/memory"
	"github.com/bitcoin-sv/ubsv/stores/txmetacache"
	"github.com/bitcoin-sv/ubsv/ulogger"

	"github.com/bitcoin-sv/ubsv/util"
	"github.com/libsv/go-bt/v2/chainhash"
	"github.com/stretchr/testify/require"
)

// This test runs a large block.Valid() test with a large number of txids
// It uses the testdata generated by the generateTestSets() function
func TestBigBlock_Valid(t *testing.T) {
	// Comment this out to run the test, it is commented, so it does not run in GitHub Actions
	//util.SkipVeryLongTests(t)
	fileDir = "./big-test-generated_test_data/"
	fileNameTemplate = fileDir + "subtree-%d.bin"
	fileNameTemplateMerkleHashes = fileDir + "subtree-merkle-hashes.bin"
	fileNameTemplateBlock = fileDir + "block.bin"
	txMetafileNameTemplate = fileDir + "txMeta.bin"
	subtreeStore := newLocalSubtreeStore()
	txIdCount := uint64(10 * 1024 * 1024)
	subtreeSize = 1024 * 1024

	// delete all the data in the ./testdata folder to regenerate the testdata
	block, err := generateTestSets(txIdCount, subtreeStore)
	require.NoError(t, err)

	txMetaStore := memory.New(ulogger.TestLogger{}, true)
	loadMetaToMemoryOnce.Do(func() {
		cachedTxMetaStore = txmetacache.NewTxMetaCache(context.Background(), ulogger.TestLogger{}, txMetaStore, 1024)
		err = loadTxMetaIntoMemory()
		require.NoError(t, err)
	})

	// check if the first txid is in the txMetaStore
	reqTxId, err := chainhash.NewHashFromStr("0000000000000000000000000000000000000000000000000000000000000001")
	require.NoError(t, err)

	data, err := cachedTxMetaStore.Get(context.Background(), reqTxId)
	require.NoError(t, err)
	require.Equal(t, &txmeta.Data{
		Fee:            1,
		SizeInBytes:    1,
		ParentTxHashes: []chainhash.Hash{},
	}, data)

	for idx, subtreeHash := range block.Subtrees {
		subtreeStore.files[*subtreeHash] = idx
	}

	currentChain := make([]*BlockHeader, 11)
	currentChainIDs := make([]uint32, 11)
	for i := 0; i < 11; i++ {
		currentChain[i] = &BlockHeader{
			HashPrevBlock:  &chainhash.Hash{},
			HashMerkleRoot: &chainhash.Hash{},
			// set the last 11 block header timestamps to be less than the current timestamps
			Timestamp: 1231469665 - uint32(i),
		}
		currentChainIDs[i] = uint32(i)
	}
	currentChain[0].HashPrevBlock = &chainhash.Hash{}
	runtime.SetCPUProfileRate(500)
	f, _ := os.Create("cpu.prof")
	defer f.Close()

	_ = pprof.StartCPUProfile(f)
	defer pprof.StopCPUProfile()

	start := time.Now()
	v, err := block.Valid(context.Background(), subtreeStore, cachedTxMetaStore, nil, currentChain, currentChainIDs)
	require.NoError(t, err)
	t.Logf("Time taken: %s\n", time.Since(start))

	f, _ = os.Create("mem.prof")
	defer f.Close()
	_ = pprof.WriteHeapProfile(f)
	require.True(t, v)
}

func Test_loadTxMetaIntoMemory(t *testing.T) {
	// Comment this out to run the test, it is commented, so it does not run in GitHub Actions
	util.SkipVeryLongTests(t)

	txMetaStore := memory.New(ulogger.TestLogger{}, true)
	cachedTxMetaStore = txmetacache.NewTxMetaCache(context.Background(), ulogger.TestLogger{}, txMetaStore)

	f, _ := os.Create("cpu.prof")
	defer f.Close()

	_ = pprof.StartCPUProfile(f)
	defer pprof.StopCPUProfile()

	err := loadTxMetaIntoMemory()
	require.NoError(t, err)

	f, _ = os.Create("mem.prof")
	defer f.Close()
	_ = pprof.WriteHeapProfile(f)
}
