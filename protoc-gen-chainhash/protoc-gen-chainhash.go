package main

import (
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			if err := generateFile(plugin, file); err != nil {
				return err
			}

		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) error {
	// Skip generating file if there is no message.
	if len(file.Messages) == 0 {
		return nil
	}

	// Read the entire file and store it in memory
	// This is done so that we can modify the message definitions
	// and write the modified file back to disk
	// This is a hacky way to do it, but it works
	inputFilePath := strings.ReplaceAll(*file.Proto.Name, ".proto", ".pb.go")

	data, err := os.ReadFile(inputFilePath)
	if err != nil {
		return err
	}

	// Step 2: Replace []byte with *chainhash.Hash
	updatedData := strings.ReplaceAll(string(data), "[]byte", "*chainhash.Hash")

	// if err := os.Remove(inputFilePath); err != nil {
	// 	return err
	// }

	g := plugin.NewGeneratedFile(inputFilePath+"1", file.GoImportPath)

	g.P(updatedData)
	// Step 3: Write the modified data back to the file
	// err = os.WriteFile(inputFilePath, []byte(updatedData), 0644)
	// if err != nil {
	// 	return err
	// }

	// Loop through messages and fields to generate modified message definitions
	/*
		for _, message := range file.Messages {
			for _, field := range message.Fields {
				fieldType := string(field.Desc.Kind().String())
				if strings.Contains(string(field.Desc.Name()), "hash") && fieldType == "BytesKind" {
					field.Desc.Kind() = "*chainhash.Hash"
				}
			}
			genFile.P("}")
			genFile.P()


		filename := file.GeneratedFilenamePrefix + "_simon.pb.go"
		g := plugin.NewGeneratedFile(filename, file.GoImportPath)
		g.P("// Code generated by protoc-gen-my-plugin. DO NOT EDIT.")
		g.P()
		g.P("package ", file.GoPackageName)
		g.P()
		g.P("import ", "\"github.com/libsv/go-bt/v2/chainhash\"")
		g.P()
		// Loop through messages and fields again to generate modified message definitions

		for _, message := range file.Messages {
			for _, field := range message.Fields {
				fieldType := string(field.Desc.Kind().String())
				if strings.Contains(string(field.Desc.Name()), "hash") && fieldType == "BytesKind" {
					field.Desc.Kind() = "*chainhash.Hash"
				}
			}
			genFile.P("}")
			genFile.P()
		}
	*/

	return nil
}
