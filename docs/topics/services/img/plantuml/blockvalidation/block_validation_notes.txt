

----- P2P Subtrees


P2P -->  Block Validation Client.SubtreeFound(ctx, hash, subtreeMessage.DataHubUrl);
          --> Block Validation Server SubtreeFound(ctx, hash, subtreeMessage.DataHubUrl)  -->
        --> Block Validation Server subtreeStore.Exists(spanCtx, subtreeHash[:]) ## check if subtree exists, if not, do not continue
        --> Validator validateSubtree(subtreeSpanCtx, subtreeHash, req.GetBaseUrl())




--- P2P - notifies about new block found ---
P2p Init() --> Block Validation Client.go NewClient()

          --> handleBlockTopic(ctx) -->  BlockValidation Client BlockFound(ctx, hash, blockMessage.DataHubUrl) --> Block Validation Server BlockFound(ctx, req)
	                                        --> Blockchain Client GetBlockExists(ctx, hash)
                                            --> u.blockFoundCh <- processBlockFound{
                                                                      hash:    hash,
                                                                      baseURL: req.GetBaseUrl(),
                                                                  }

                                            blockFoundCh --> Block Validation Server processBlockFound(ctx1, b.hash, b.baseURL)
                                                                    --> blockchainClient.GetBlockExists(ctx, hash)
                                                                    --> getBlock(ctx, hash, baseUrl) --> util.DoHTTPRequest(spanCtx, fmt.Sprintf("%s/block/%s", baseUrl, hash.String())) ## Download block from remote node
                                                                    --> blockchainClient.GetBlockExists(ctx, block.Header.HashPrevBlock) ## Check if we know about the parent block
                                                                        ##If not exists, add to the channel for it to be found (this will iterate until we reach a known point). catchupCh <- processBlockCatchup{
                                                                                      block:   block,
                                                                                      baseURL: baseUrl,
                                                                                  }
                                                                    --> BlockValidation.go ValidateBlock(ctx, block, baseUrl) --> BlockValidation.go validateBLockSubtrees(spanCtx, block, baseUrl) --> for each subtree --> subtreeStore.Exists(spanCtx, subtreeHash)
                                                                                                                                                                                                                         --> if not exists --> validateSubtree(ctx1, subtreeHash, baseUrl)
                                                                                                                              --> blockchainClient.GetBlockHeaders(spanCtx, block.Header.HashPrevBlock, 100)
                                                                                                                              --> storeCoinbaseTx(spanCtx, block)  --> u.txMetaStore.Create(ctx, block.CoinbaseTx)
                                                                                                                              --> block.Valid(spanCtx, u.subtreeStore, u.txMetaStore, blockHeaders) ## Check if it is valid, using the last 100 block headers
                                                                                                                              --> blockchainClient.AddBlock(spanCtx, block, baseUrl)  ## Add block to the blockchain
                                                                                                                              --> txStore.Set(spanCtx, block.CoinbaseTx.TxIDChainHash()[:], block.CoinbaseTx.Bytes()) #Store coinbase TX - had we not done it already????
                                                                                                                              --> finalizeBlockValidation(setCtx, block)  --> block.GetSubtrees(u.subtreeStore)  --> for each u.updateSubtreesTTL(gCtx, block)
                                                                                                                                                                           --> update-tx-mined.go        model.UpdateTxMinedStatus(gCtx, u.logger, u.txMetaStore, subtrees, block.Header) // add the transactions in this block to the txMeta block hashes   --> for each subtree --> for each Node (tx) in the subtree --> txMetaStore.SetMinedMulti(gCtx, hashes, blockHeaderHash) ## mark tx as mined
                                                                                                                                                                           --> if error --> blockchainClient.InvalidateBlock(setCtx, block.Header.Hash())
--- Block Validation init ---

Server.go Init() --> catchupCh channel -->  Server.go u.catchup(ctx1, c.block, c.baseURL) --> blockchainClient.GetBlockExists(spanCtx, fromBlock.Hash()) ## verify before proceeding
--> if not exists --> Loop until a parent block is found --> Server.go u.getBlockHeaders(spanCtx, fromBlockHeaderHash, baseURL) --> for each block header
--> u.blockchainClient.GetBlockExists(spanCtx, blockHeader.Hash()) ## verify before we go ahead and spend time
--> Server.go  u.getBlock(spanCtx, blockHeader.Hash(), baseURL) --> util.DoHTTPRequest() ## Download block from remote node


Validate Subtree Sequence -- validateSubtree(ctx, subtreeHash, baseURL)

Server.go
