@startuml
participant "P2P" as P2P
participant "Block Validation Client" as BVC
participant "Block Validation Server" as BVS
participant "Validator" as ValidateSubtree
entity "Subtree Data" as SubtreeData
participant "Util HTTP Request" as Util
database "Subtree Store" as SubtreeStore
database "Tx Meta Store" as TxMetaStore

P2P -> BVC: SubtreeFound(ctx, hash, subtreeMessage.DataHubUrl)
activate BVC
BVC -> BVS: SubtreeFound(ctx, hash, subtreeMessage.DataHubUrl)
deactivate BVC
activate BVS

BVS -> SubtreeStore: subtreeStore.Exists(spanCtx, subtreeHash[:])
activate SubtreeStore
SubtreeStore --> BVS: subtreeExists / err
deactivate SubtreeStore

BVS -> ValidateSubtree: validateSubtree(subtreeSpanCtx, subtreeHash, req.GetBaseUrl())
deactivate BVS

' Existing Sequence
activate ValidateSubtree

ValidateSubtree -> SubtreeStore: subtreeStore.Exists(spanCtx, subtreeHash[:])
activate SubtreeStore
SubtreeStore --> ValidateSubtree: subtreeExists / err
deactivate SubtreeStore

alt subtreeExists is false
    ValidateSubtree -> Util: DoHTTPRequest(spanCtx, url)
    activate Util
    Util --> ValidateSubtree: subtreeBytes / err
    deactivate Util

    ValidateSubtree -> ValidateSubtree: Process subtreeBytes
    activate TxMetaStore
    loop for each txHash
       ValidateSubtree -> TxMetaStore: txMetaStore.GetMeta(gCtx, &txHash)
        TxMetaStore --> ValidateSubtree: txMeta / err
    end
    deactivate TxMetaStore

    ValidateSubtree -> ValidateSubtree: processMissingTransactions(ctx, subtreeHash, missingTxHashesCompacted, baseUrl, txMetaSlice)

    ValidateSubtree -> SubtreeData: Add transactions to Subtree

    ValidateSubtree -> SubtreeData: AddNode(txHash, txMeta.Fee, txMeta.SizeInBytes)

    ValidateSubtree -> SubtreeStore: Set(spanCtx, merkleRoot[:], completeSubtreeBytes)
    activate SubtreeStore
    SubtreeStore --> ValidateSubtree
    deactivate SubtreeStore
end

deactivate ValidateSubtree
@enduml
