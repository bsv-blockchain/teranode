
- TX Validator  ba := blockassembly.NewClient(ctx, logger)
  enabled := gocore.Config().GetBool("blockvalidation_txMetaCacheBatcherEnabled", true)
  --> blockAssembler client Store(ctx, bData.TxIDChainHash, bData.Fee, bData.Size, bData.LockTime, bData.UtxoHashes)
    --> it goes to either AddTx(subtreeNode) ##  frpc client, drpc client, or grpc client without batching
       --> subtreeProcessor.Add(node)
    --> or it goes to a batches that eventually sends to Server.go AddTxBatch(ctx, nodeBatch) ## if frpc, drpc, grpc client with batching
        --> for each node in nodeBatch, self AddTx(subtreeNode) --> subtreeProcessor.Add(node)



SubtreeProcessor - txReq = queue.dequeue()
SubtreeProcessor addNode(txReq, false) --> self currentSubtree.AddSubtreeNode(txReq) -->
--> if stp.currentSubtree.IsComplete()  --> send currentSubTree to Server.go newSubtreeChan


Server.go newSubtreeChan --> check it does not exist subtreeStore.Exists(ctx, subtree.RootHash()[:]) --> subtreeStore.Set(ctx,
subtree.RootHash()[:],
subtreeBytes,
options.WithTTL(ba.subtreeTTL),
)
--> blockchainClient.SendNotification(ctx, &model.Notification{
Type: model.NotificationType_Subtree,
Hash: subtree.RootHash(),
})


- Miner --> blockAssemblyClient.GetMiningCandidate(ctx)
  --> Block Assembly Server.go GetMiningCandidate(ctx) -->
  --> blockAssembler.GetMiningCandidate(ctx) --> subtreeProcessor.GetCompletedSubtreesForMiningCandidate() -->    blockAssembler  coinbaseValue = util.GetBlockSubsidyForHeight(b.bestBlockHeight + 1) + subtreeFees
  -->blockAssembler   compute coinbase Tx merkle proof --> return mining candidate with coinbase Tx and merkle proof and fees and list of subtrees composing the candidate block

              --> statusClient.AnnounceStatus(ctx, &model.AnnounceStatusRequest{
                  Timestamp: timestamppb.New(now),
                    Type:      "GetMiningCandidate",
                    Subtype:   "Height",
                    Value:     fmt.Sprintf("%d", miningCandidate.Height),
                    ExpiresAt: timestamppb.New(now.Add(30 * time.Second)),
                  })
              --> statusClient.AnnounceStatus(ctx, &model.AnnounceStatusRequest{
                    Timestamp: timestamppb.New(now),
                    Type:      "GetMiningCandidate",
                    Subtype:   "PreviousHash",
                    Value:     utils.ReverseAndHexEncodeSlice(miningCandidate.PreviousHash),
                    ExpiresAt: timestamppb.New(now.Add(30 * time.Second)),
              })
              --> 	ba.jobStore.Set(*id, &subtreeprocessor.Job{
                          ID:              id,
                          Subtrees:        subtrees,
                          MiningCandidate: miningCandidate,
                      }, jobTTL) // create a new job with a TTL, will be cleaned up automatically




-- Gets a Nonce --> Mining       --> blockAssemblyClient.SubmitMiningSolution(ctx, solution)
  --> Block Assembly Server            SubmitMiningSolution(ctx, solution)
  --> blockSumbmissionCh add
  -->  Block Assembly Server submitMiningSolution(ctx, blockSubmission) --> Block Assembly Server jobItem = jobStore.Get(*storeId) -->  Block Assembly Server req.Nonce -->  Block Assembly Server create new block with miner proof of work
  --> block.Valid(cntxt, nil, nil, nil) --> txStore.Set(context.Background(), block.CoinbaseTx.TxIDChainHash().CloneBytes(), block.CoinbaseTx.ExtendedBytes())
  --> txMetaStore.Create(cntxt, block.CoinbaseTx)
  --> blockchainClient.AddBlock(cntxt, block, "")
  --> removeSubtreesTTL(gCtx, block) --> for each subtree subtreeStore.SetTTL(setCtx, subtreeHashBytes, 0)
  --> model.UpdateTxMinedStatus(gCtx, ba.logger, ba.txMetaStore, subtreesInJob, block.Header) --> txMetaStore.SetMinedMulti(gCtx, hashes, blockHeaderHash)
  --> jobStore.DeleteAll()
  --> If any error --> blockchainClient.InvalidateBlock(setCtx, block.Header.Hash())
