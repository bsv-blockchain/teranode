import { writable } from 'svelte/store';

const BOOTSTRAP_SERVER="https://bootstrap.ubsv.dev:8099"
// const BOOTSTRAP_SERVER="https://localhost:8099"

// WebSocket connection URL
const wsUrl="wss://localhost:8090/ws"


// Create a writable store
export const nodes = writable([]);
export const blocks = writable([]);
export const error = writable("");
export const loading = writable(false);

function timeout(ms) {
  return new Promise((_, reject) => setTimeout(() => reject(new Error('Promise timed out')), ms));
}

async function fetchData() {
  try {
    loading.set(true);

    const n = await getNodes();

    await Promise.all(
      n.map(async (node) => {
        if (node.blobServerHTTPAddress) {
          try {
            const header = await Promise.race([
              getBestBlockHeader(node.blobServerHTTPAddress),
              timeout(1000)
            ]);
            node.header = header; // Add the header directly to the node
          } catch (error) {
            console.error(`Error fetching header for node ${node.id}:`, error.message);
            node.header = { error: "timeout" }; // Add the error directly to the node
          }
        } else {
          node.header = {}; // Add an empty header object if no blobServerHTTPAddress
        }
      })
    );

    // Go through all the nodes and get a unique list of hashes. Store these in a map
    // along with the address of the server that has the hash.
    const hs = {};

    n.forEach((node) => { // Use forEach instead of map
      if (node.header && node.header.hash && node.blobServerHTTPAddress) {
        hs[node.header.hash] = node.blobServerHTTPAddress;
      }
    });

    const b = await getBestBlocks();

    // Update the stores
    nodes.set(n);
    blocks.set(b);
    error.set("");

    // Call fetchData() again in 1s
    setTimeout(fetchData, 3000);
  } catch (err) {
    console.error(err)
    error.set(err.message);
  } finally {
    loading.set(false);
  }
}

async function getNodes() {
  const response = await fetch(`${BOOTSTRAP_SERVER}/nodes`);

  if (!response.ok) {
    throw new Error(`HTTP error! Status: ${response.status}`);
  }

  const n = await response.json();

  return n.sort((a, b) => {
    if (a.name < b.name) return -1;
    if (a.name > b.name) return 1;
    return 0;
  });
}


async function getBestBlockHeader(address) {
  const url = `${address}/bestblockheader/json`
  // console.log("Fetching", url)
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`HTTP error! Status: ${response.status}`);
  }

  return await response.json();
}

async function getLast10Blocks(hash, address) {
  const url = `${address}/headers/${hash}/json?n=10`
  // console.log("Fetching", url)
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`HTTP error! Status: ${response.status}`);
  }

  return await response.json();
}

export const websocketStore = writable(null, (set) => {
  const socket = new WebSocket(wsUrl);

  socket.onopen = () => {
    console.log(`WebSocket connection opened to ${wsUrl}`);
  };

  socket.onmessage = async (event) => {
    try {
      const data = await event.data.text()
      set(data);
    } catch (error) {
      console.error('Error parsing WebSocket data:', error);
    }
  };

  socket.onclose = () => {
    console.log(`WebSocket connection closed to ${wsUrl}`);
    // Reconnect logic can be added here if needed
  };

  // Cleanup function
  return () => {
    socket.close();
  };
});


// Call fetchData() once on load
fetchData();
