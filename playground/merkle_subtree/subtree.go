package main

import (
	"fmt"
	"math"

	"github.com/libsv/go-bk/crypto"
	"github.com/libsv/go-p2p/chaincfg/chainhash"
)

type SubTree struct {
	rootHash *chainhash.Hash
	treeSize int
	Height   int
	Nodes    []*chainhash.Hash
}

// NewTree creates a new SubTree with a fixed height
func NewTree(height int) *SubTree {
	var treeSize = int(math.Pow(2, float64(height))) // 1024 * 1024
	return &SubTree{
		Nodes:    make([]*chainhash.Hash, 0, treeSize),
		Height:   height,
		treeSize: treeSize,
	}
}

func (st *SubTree) Size() int {
	return cap(st.Nodes)
}

func (st *SubTree) IsComplete() bool {
	return len(st.Nodes) == cap(st.Nodes)
}

func (st *SubTree) ReplaceRootNode(node *chainhash.Hash) *chainhash.Hash {
	st.Nodes[0] = node
	st.rootHash = nil // reset rootHash

	return st.RootHash()
}

func (st *SubTree) AddNode(node *chainhash.Hash) error {
	if (len(st.Nodes) + 1) > st.treeSize {
		return fmt.Errorf("subTree is full")
	}

	st.Nodes = append(st.Nodes, node)
	st.rootHash = nil // reset rootHash

	return nil
}

func (st *SubTree) AddNodes(nodes []*chainhash.Hash) error {
	if (len(st.Nodes) + len(nodes)) > st.treeSize {
		return fmt.Errorf("subTree is full")
	}

	st.Nodes = append(st.Nodes, nodes...)
	st.rootHash = nil // reset rootHash

	return nil
}

func (st *SubTree) RootHash() *chainhash.Hash {
	if st.rootHash != nil {
		return st.rootHash
	}

	// calculate rootHash
	store, err := st.BuildMerkleTreeStoreFromBytes()
	if err != nil {
		return nil
	}

	st.rootHash = store[len(store)-1]

	return st.rootHash
}

func (st *SubTree) BuildMerkleTreeStoreFromBytes() ([]*chainhash.Hash, error) {
	// Calculate how many entries are re?n array of that size.
	nextPoT := st.nextPowerOfTwo(len(st.Nodes))
	arraySize := nextPoT*2 - 1
	merkles := make([]*chainhash.Hash, arraySize)

	// Create the base transaction hashes and populate the array with them.
	copy(merkles, st.Nodes)

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	offset := nextPoT
	var concat [64]byte
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil ("") too.
		case merkles[i] == nil || *merkles[i] == chainhash.Hash{}:
			merkles[offset] = &chainhash.Hash{}

		// When there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself.
		case merkles[i+1] == nil || *merkles[i+1] == chainhash.Hash{}:
			copy(concat[:32], merkles[i][:])
			copy(concat[32:], merkles[i+1][:])
			hash := crypto.Sha256d(concat[:])
			merkles[offset], _ = chainhash.NewHash(hash)

			// The normal case sets the parent node to the double sha256
			// of the concatenation of the left and right children.
		default:
			copy(concat[:32], merkles[i][:])
			copy(concat[32:], merkles[i+1][:])
			hash := crypto.Sha256d(concat[:])
			merkles[offset], _ = chainhash.NewHash(hash)
		}
		offset++
	}

	return merkles, nil
}

// nextPowerOfTwo returns the next highest power of two from a given number if
// it is not already a power of two.  This is a helper function used during the
// calculation of a merkle tree.
func (st *SubTree) nextPowerOfTwo(n int) int {
	// Return the number if it's already a power of 2.
	if n&(n-1) == 0 {
		return n
	}

	// Figure out and return the next power of two.
	exponent := uint(math.Log2(float64(n))) + 1
	return 1 << exponent // 2^exponent
}
