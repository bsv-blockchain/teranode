package main

import (
	"encoding/binary"
	"fmt"
	"math"
	"runtime"
	"time"

	"github.com/libsv/go-bc"
	"github.com/libsv/go-bk/crypto"
	"github.com/ordishs/go-utils"
	"github.com/pkg/profile"
)

func main() {
	runtime.GC()
	printAlloc()

	keySlice := make([]string, 1_000_000)
	keySliceBytes := make([][32]byte, 1_000_000)

	key := make([]byte, 32)
	for i := uint64(0); i < 1_000_000; i++ {
		// convert int to byte array
		binary.LittleEndian.PutUint64(key, i)
		keySlice[i] = utils.ReverseAndHexEncodeHash([32]byte(key[:32]))
		keySliceBytes[i] = [32]byte(key[:32])
	}

	fmt.Printf("Keys length: %d\n", len(keySlice))
	fmt.Printf("Key bytes length: %d\n", len(keySliceBytes))

	printAlloc()

	timeStart := time.Now()
	_, _ = bc.BuildMerkleTreeStore(keySlice)
	fmt.Printf("Time taken for go-bc string version: %s\n", time.Since(timeStart))

	defer profile.Start(profile.ProfilePath(".")).Stop()

	timeStart = time.Now()
	_, _ = BuildMerkleTreeStoreFromBytes(keySliceBytes)
	fmt.Printf("Time taken for bytes version: %s\n", time.Since(timeStart))
}

func printAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("%d KB\n", m.Alloc/1024)
}

func BuildMerkleTreeStoreFromBytes(txids [][32]byte) ([][32]byte, error) {
	// // Calculate how many entries are re?n array of that size.
	nextPoT := nextPowerOfTwo(len(txids))
	arraySize := nextPoT*2 - 1
	merkles := make([][32]byte, arraySize)

	// Create the base transaction hashes and populate the array with them.
	copy(merkles, txids)

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	offset := nextPoT
	var concat [64]byte
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil ("") too.
		case merkles[i] == [32]byte{}:
			merkles[offset] = [32]byte{}

		// When there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself.
		case merkles[i+1] == [32]byte{}:
			copy(concat[:32], merkles[i][:])
			copy(concat[32:], merkles[i+1][:])
			hash := crypto.Sha256d(concat[:])
			merkles[offset] = [32]byte(hash)

			// The normal case sets the parent node to the double sha256
			// of the concatenation of the left and right children.
		default:
			copy(concat[:32], merkles[i][:])
			copy(concat[32:], merkles[i+1][:])
			hash := crypto.Sha256d(concat[:])
			merkles[offset] = [32]byte(hash)
		}
		offset++
	}

	return merkles, nil
}

// nextPowerOfTwo returns the next highest power of two from a given number if
// it is not already a power of two.  This is a helper function used during the
// calculation of a merkle tree.
func nextPowerOfTwo(n int) int {
	// Return the number if it's already a power of 2.
	if n&(n-1) == 0 {
		return n
	}

	// Figure out and return the next power of two.
	exponent := uint(math.Log2(float64(n))) + 1
	return 1 << exponent // 2^exponent
}
