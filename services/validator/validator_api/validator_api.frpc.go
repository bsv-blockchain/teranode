// Code generated by fRPC Go v0.7.3, DO NOT EDIT.
// source: services/validator/validator_api/validator_api.proto

package validator_api

import (
	"errors"
	"github.com/loopholelabs/polyglot"
	"net"

	"context"
	"crypto/tls"
	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/rs/zerolog"

	"sync"

	"go.uber.org/atomic"
	"io"
)

var (
	ErrNilDecode = errors.New("cannot decode into a nil root struct")
)

type ValidatorApiEmptyMessage struct {
	error error
	flags uint8
}

func NewValidatorApiEmptyMessage() *ValidatorApiEmptyMessage {
	return &ValidatorApiEmptyMessage{}
}

func (x *ValidatorApiEmptyMessage) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiEmptyMessage) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *ValidatorApiEmptyMessage) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiEmptyMessage) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type ValidatorApiHealthResponse struct {
	error error
	flags uint8

	Ok        bool
	Details   string
	Timestamp uint32
}

func NewValidatorApiHealthResponse() *ValidatorApiHealthResponse {
	return &ValidatorApiHealthResponse{}
}

func (x *ValidatorApiHealthResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiHealthResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Ok).String(x.Details).Uint32(x.Timestamp)
	}
}

func (x *ValidatorApiHealthResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiHealthResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ok, err = d.Bool()
	if err != nil {
		return err
	}
	x.Details, err = d.String()
	if err != nil {
		return err
	}
	x.Timestamp, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type ValidatorApiValidateTransactionRequest struct {
	error error
	flags uint8

	TransactionData []byte
}

func NewValidatorApiValidateTransactionRequest() *ValidatorApiValidateTransactionRequest {
	return &ValidatorApiValidateTransactionRequest{}
}

func (x *ValidatorApiValidateTransactionRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiValidateTransactionRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.TransactionData)
	}
}

func (x *ValidatorApiValidateTransactionRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiValidateTransactionRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.TransactionData, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	return nil
}

type ValidatorApiValidateTransactionResponse struct {
	error error
	flags uint8

	Valid  bool
	Reason string
}

func NewValidatorApiValidateTransactionResponse() *ValidatorApiValidateTransactionResponse {
	return &ValidatorApiValidateTransactionResponse{}
}

func (x *ValidatorApiValidateTransactionResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiValidateTransactionResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Valid).String(x.Reason)
	}
}

func (x *ValidatorApiValidateTransactionResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiValidateTransactionResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Valid, err = d.Bool()
	if err != nil {
		return err
	}
	x.Reason, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type ValidatorApiValidateTransactionBatchRequest struct {
	error error
	flags uint8

	Transactions []*ValidatorApiValidateTransactionRequest
}

func NewValidatorApiValidateTransactionBatchRequest() *ValidatorApiValidateTransactionBatchRequest {
	return &ValidatorApiValidateTransactionBatchRequest{}
}

func (x *ValidatorApiValidateTransactionBatchRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiValidateTransactionBatchRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		polyglot.Encoder(b).Slice(uint32(len(x.Transactions)), polyglot.AnyKind)
		for _, v := range x.Transactions {
			v.Encode(b)
		}
	}
}

func (x *ValidatorApiValidateTransactionBatchRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiValidateTransactionBatchRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Transactions)) != sliceSize {
		x.Transactions = make([]*ValidatorApiValidateTransactionRequest, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.Transactions[i] == nil {
			x.Transactions[i] = NewValidatorApiValidateTransactionRequest()
		}
		err = x.Transactions[i].decode(d)
		if err != nil {
			return err
		}
	}
	return nil
}

type ValidatorApiValidateTransactionError struct {
	error error
	flags uint8

	TxId   string
	Reason string
}

func NewValidatorApiValidateTransactionError() *ValidatorApiValidateTransactionError {
	return &ValidatorApiValidateTransactionError{}
}

func (x *ValidatorApiValidateTransactionError) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiValidateTransactionError) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.TxId).String(x.Reason)
	}
}

func (x *ValidatorApiValidateTransactionError) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiValidateTransactionError) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.TxId, err = d.String()
	if err != nil {
		return err
	}
	x.Reason, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type ValidatorApiValidateTransactionBatchResponse struct {
	error error
	flags uint8

	Valid   bool
	Reasons []*ValidatorApiValidateTransactionError
}

func NewValidatorApiValidateTransactionBatchResponse() *ValidatorApiValidateTransactionBatchResponse {
	return &ValidatorApiValidateTransactionBatchResponse{}
}

func (x *ValidatorApiValidateTransactionBatchResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiValidateTransactionBatchResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Valid)
		polyglot.Encoder(b).Slice(uint32(len(x.Reasons)), polyglot.AnyKind)
		for _, v := range x.Reasons {
			v.Encode(b)
		}
	}
}

func (x *ValidatorApiValidateTransactionBatchResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiValidateTransactionBatchResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Valid, err = d.Bool()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Reasons)) != sliceSize {
		x.Reasons = make([]*ValidatorApiValidateTransactionError, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.Reasons[i] == nil {
			x.Reasons[i] = NewValidatorApiValidateTransactionError()
		}
		err = x.Reasons[i].decode(d)
		if err != nil {
			return err
		}
	}
	return nil
}

type ValidatorApiGetBlockHeightResponse struct {
	error error
	flags uint8

	Height uint32
}

func NewValidatorApiGetBlockHeightResponse() *ValidatorApiGetBlockHeightResponse {
	return &ValidatorApiGetBlockHeightResponse{}
}

func (x *ValidatorApiGetBlockHeightResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiGetBlockHeightResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Uint32(x.Height)
	}
}

func (x *ValidatorApiGetBlockHeightResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiGetBlockHeightResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Height, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type ValidatorApiSubscribeRequest struct {
	error error
	flags uint8

	Source string
}

func NewValidatorApiSubscribeRequest() *ValidatorApiSubscribeRequest {
	return &ValidatorApiSubscribeRequest{}
}

func (x *ValidatorApiSubscribeRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiSubscribeRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Source)
	}
}

func (x *ValidatorApiSubscribeRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiSubscribeRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Source, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type ValidatorApiRejectedTxNotification struct {
	error error
	flags uint8

	TxId   string
	Reason string
}

func NewValidatorApiRejectedTxNotification() *ValidatorApiRejectedTxNotification {
	return &ValidatorApiRejectedTxNotification{}
}

func (x *ValidatorApiRejectedTxNotification) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ValidatorApiRejectedTxNotification) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.TxId).String(x.Reason)
	}
}

func (x *ValidatorApiRejectedTxNotification) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *ValidatorApiRejectedTxNotification) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.TxId, err = d.String()
	if err != nil {
		return err
	}
	x.Reason, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type ValidatorAPI interface {
	HealthGRPC(context.Context, *ValidatorApiEmptyMessage) (*ValidatorApiHealthResponse, error)
	ValidateTransaction(context.Context, *ValidatorApiValidateTransactionRequest) (*ValidatorApiValidateTransactionResponse, error)
	ValidateTransactionBatch(context.Context, *ValidatorApiValidateTransactionBatchRequest) (*ValidatorApiValidateTransactionBatchResponse, error)

	ValidateTransactionStream(srv *ValidateTransactionStreamServer) error
	GetBlockHeight(context.Context, *ValidatorApiEmptyMessage) (*ValidatorApiGetBlockHeightResponse, error)

	Subscribe(req *ValidatorApiSubscribeRequest, srv *SubscribeServer) error
}

type contextKey int

const connectionContextKey contextKey = 1000

func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

type RPCStreamOpen struct {
	operation uint16
}

func (x *RPCStreamOpen) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *RPCStreamOpen) Encode(b *polyglot.Buffer) {
	polyglot.Encoder(b).Uint16(x.operation)
}

func (x *RPCStreamOpen) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *RPCStreamOpen) decode(d *polyglot.Decoder) error {
	var err error
	x.operation, err = d.Uint16()
	return err
}

type Server struct {
	*frisbee.Server
	onClosed func(*frisbee.Async, error)
}

func NewServer(validatorAPI ValidatorAPI, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
	var s *Server
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewValidatorApiEmptyMessage()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *ValidatorApiHealthResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = validatorAPI.HealthGRPC(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewValidatorApiValidateTransactionRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *ValidatorApiValidateTransactionResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = validatorAPI.ValidateTransaction(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewValidatorApiValidateTransactionBatchRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *ValidatorApiValidateTransactionBatchResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = validatorAPI.ValidateTransactionBatch(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[14] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewValidatorApiEmptyMessage()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *ValidatorApiGetBlockHeightResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = validatorAPI.GetBlockHeight(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	var fsrv *frisbee.Server
	var err error
	if tlsConfig != nil {
		fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	fsrv.SetStreamHandler(func(conn *frisbee.Async, stream *frisbee.Stream) {
		p, err := stream.ReadPacket()
		if err != nil {
			return
		}
		open := &RPCStreamOpen{}
		err = open.Decode(*p.Content)
		if err != nil {
			stream.Close()
			return
		}
		switch open.operation {
		case 13:
			s.createValidateTransactionStreamServer(validatorAPI, stream)
		case 15:
			s.createSubscribeServer(validatorAPI, stream)
		}
	})

	fsrv.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, connectionContextKey, conn)
	}
	s, err = &Server{
		Server: fsrv,
	}, nil

	fsrv.SetOnClosed(func(async *frisbee.Async, err error) {
		if s.onClosed != nil {
			s.onClosed(async, err)
		}
	})
	return s, err
}

func (s *Server) SetOnClosed(f func(*frisbee.Async, error)) error {
	if f == nil {
		return frisbee.OnClosedNil
	}
	s.onClosed = f
	return nil
}

type ValidateTransactionStreamServer struct {
	recv func() (*ValidatorApiValidateTransactionRequest, error)
	send func(*ValidatorApiValidateTransactionResponse) error

	stream *frisbee.Stream
	closed *atomic.Bool
}

func (s *Server) createValidateTransactionStreamServer(validatorAPI ValidatorAPI, stream *frisbee.Stream) {
	srv := &ValidateTransactionStreamServer{
		closed: atomic.NewBool(false),
		stream: stream,
	}

	srv.recv = func() (*ValidatorApiValidateTransactionRequest, error) {
		p, err := srv.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewValidatorApiValidateTransactionRequest()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}
	srv.send = func(m *ValidatorApiValidateTransactionResponse) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return srv.stream.WritePacket(p)
	}

	go func() {
		err := validatorAPI.ValidateTransactionStream(srv)
		if err != nil {
			res := ValidatorApiValidateTransactionResponse{error: err}
			res.flags = SetErrorFlag(res.flags, true)
			srv.CloseAndSend(&res)
		} else {
			srv.CloseSend()
		}
	}()
}

func (x *ValidateTransactionStreamServer) Recv() (*ValidatorApiValidateTransactionRequest, error) {
	return x.recv()
}

func (x *ValidateTransactionStreamServer) close() {
	x.stream.Close()
}
func (x *ValidateTransactionStreamServer) CloseSend() error {
	return x.send(&ValidatorApiValidateTransactionResponse{error: io.EOF})
}

func (x *ValidateTransactionStreamServer) CloseAndSend(m *ValidatorApiValidateTransactionResponse) error {
	err := x.send(m)
	if err != nil {
		return err
	}
	return x.CloseSend()
}

type SubscribeServer struct {
	recv func() (*ValidatorApiSubscribeRequest, error)
	send func(*ValidatorApiRejectedTxNotification) error

	stream *frisbee.Stream
	closed *atomic.Bool
}

func (s *Server) createSubscribeServer(validatorAPI ValidatorAPI, stream *frisbee.Stream) {
	srv := &SubscribeServer{
		closed: atomic.NewBool(false),
		stream: stream,
	}

	srv.send = func(m *ValidatorApiRejectedTxNotification) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return srv.stream.WritePacket(p)
	}

	incoming, err := stream.ReadPacket()
	if err != nil {
		return
	}
	req := NewValidatorApiSubscribeRequest()
	_ = req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
	go func() {

		err := validatorAPI.Subscribe(req, srv)
		if err != nil {
			res := ValidatorApiRejectedTxNotification{error: err}
			res.flags = SetErrorFlag(res.flags, true)
			srv.CloseAndSend(&res)
		} else {
			srv.CloseSend()
		}
	}()
}

func (x *SubscribeServer) Send(m *ValidatorApiRejectedTxNotification) error {
	return x.send(m)
}
func (x *SubscribeServer) CloseSend() error {
	return x.send(&ValidatorApiRejectedTxNotification{error: io.EOF})
}

func (x *SubscribeServer) CloseAndSend(m *ValidatorApiRejectedTxNotification) error {
	err := x.send(m)
	if err != nil {
		return err
	}
	return x.CloseSend()
}

type subValidatorAPIClient struct {
	client                             *frisbee.Client
	nextHealthGRPC                     uint16
	nextHealthGRPCMu                   sync.RWMutex
	inflightHealthGRPC                 map[uint16]chan *ValidatorApiHealthResponse
	inflightHealthGRPCMu               sync.RWMutex
	nextValidateTransaction            uint16
	nextValidateTransactionMu          sync.RWMutex
	inflightValidateTransaction        map[uint16]chan *ValidatorApiValidateTransactionResponse
	inflightValidateTransactionMu      sync.RWMutex
	nextValidateTransactionBatch       uint16
	nextValidateTransactionBatchMu     sync.RWMutex
	inflightValidateTransactionBatch   map[uint16]chan *ValidatorApiValidateTransactionBatchResponse
	inflightValidateTransactionBatchMu sync.RWMutex
	nextGetBlockHeight                 uint16
	nextGetBlockHeightMu               sync.RWMutex
	inflightGetBlockHeight             map[uint16]chan *ValidatorApiGetBlockHeightResponse
	inflightGetBlockHeightMu           sync.RWMutex
	nextStreamingID                    uint16
	nextStreamingIDMu                  sync.RWMutex
}
type Client struct {
	*frisbee.Client
	ValidatorAPI *subValidatorAPIClient
}

func NewClient(tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.ValidatorAPI.inflightHealthGRPCMu.RLock()
		if ch, ok := c.ValidatorAPI.inflightHealthGRPC[incoming.Metadata.Id]; ok {
			c.ValidatorAPI.inflightHealthGRPCMu.RUnlock()
			res := NewValidatorApiHealthResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.ValidatorAPI.inflightHealthGRPCMu.RUnlock()
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.ValidatorAPI.inflightValidateTransactionMu.RLock()
		if ch, ok := c.ValidatorAPI.inflightValidateTransaction[incoming.Metadata.Id]; ok {
			c.ValidatorAPI.inflightValidateTransactionMu.RUnlock()
			res := NewValidatorApiValidateTransactionResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.ValidatorAPI.inflightValidateTransactionMu.RUnlock()
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.ValidatorAPI.inflightValidateTransactionBatchMu.RLock()
		if ch, ok := c.ValidatorAPI.inflightValidateTransactionBatch[incoming.Metadata.Id]; ok {
			c.ValidatorAPI.inflightValidateTransactionBatchMu.RUnlock()
			res := NewValidatorApiValidateTransactionBatchResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.ValidatorAPI.inflightValidateTransactionBatchMu.RUnlock()
		}
		return
	}
	table[14] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.ValidatorAPI.inflightGetBlockHeightMu.RLock()
		if ch, ok := c.ValidatorAPI.inflightGetBlockHeight[incoming.Metadata.Id]; ok {
			c.ValidatorAPI.inflightGetBlockHeightMu.RUnlock()
			res := NewValidatorApiGetBlockHeightResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.ValidatorAPI.inflightGetBlockHeightMu.RUnlock()
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.ValidatorAPI = new(subValidatorAPIClient)
	c.ValidatorAPI.client = c.Client
	c.ValidatorAPI.nextHealthGRPCMu.Lock()
	c.ValidatorAPI.nextHealthGRPC = 0
	c.ValidatorAPI.nextHealthGRPCMu.Unlock()
	c.ValidatorAPI.inflightHealthGRPC = make(map[uint16]chan *ValidatorApiHealthResponse)
	c.ValidatorAPI.nextValidateTransactionMu.Lock()
	c.ValidatorAPI.nextValidateTransaction = 0
	c.ValidatorAPI.nextValidateTransactionMu.Unlock()
	c.ValidatorAPI.inflightValidateTransaction = make(map[uint16]chan *ValidatorApiValidateTransactionResponse)
	c.ValidatorAPI.nextValidateTransactionBatchMu.Lock()
	c.ValidatorAPI.nextValidateTransactionBatch = 0
	c.ValidatorAPI.nextValidateTransactionBatchMu.Unlock()
	c.ValidatorAPI.inflightValidateTransactionBatch = make(map[uint16]chan *ValidatorApiValidateTransactionBatchResponse)
	c.ValidatorAPI.nextGetBlockHeightMu.Lock()
	c.ValidatorAPI.nextGetBlockHeight = 0
	c.ValidatorAPI.nextGetBlockHeightMu.Unlock()
	c.ValidatorAPI.inflightGetBlockHeight = make(map[uint16]chan *ValidatorApiGetBlockHeightResponse)
	return c, nil
}

func (c *Client) Connect(addr string, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.Connect(addr, func(stream *frisbee.Stream) {})
}

func (c *Client) FromConn(conn net.Conn, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.FromConn(conn, func(stream *frisbee.Stream) {})
}

func (c *subValidatorAPIClient) HealthGRPC(ctx context.Context, req *ValidatorApiEmptyMessage) (res *ValidatorApiHealthResponse, err error) {
	ch := make(chan *ValidatorApiHealthResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextHealthGRPCMu.Lock()
	c.nextHealthGRPC += 1
	id := c.nextHealthGRPC
	c.nextHealthGRPCMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightHealthGRPCMu.Lock()
	c.inflightHealthGRPC[id] = ch
	c.inflightHealthGRPCMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightHealthGRPCMu.Lock()
	delete(c.inflightHealthGRPC, id)
	c.inflightHealthGRPCMu.Unlock()
	packet.Put(p)
	return
}

func (c *subValidatorAPIClient) ValidateTransaction(ctx context.Context, req *ValidatorApiValidateTransactionRequest) (res *ValidatorApiValidateTransactionResponse, err error) {
	ch := make(chan *ValidatorApiValidateTransactionResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 11

	c.nextValidateTransactionMu.Lock()
	c.nextValidateTransaction += 1
	id := c.nextValidateTransaction
	c.nextValidateTransactionMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightValidateTransactionMu.Lock()
	c.inflightValidateTransaction[id] = ch
	c.inflightValidateTransactionMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightValidateTransactionMu.Lock()
	delete(c.inflightValidateTransaction, id)
	c.inflightValidateTransactionMu.Unlock()
	packet.Put(p)
	return
}

func (c *subValidatorAPIClient) ValidateTransactionBatch(ctx context.Context, req *ValidatorApiValidateTransactionBatchRequest) (res *ValidatorApiValidateTransactionBatchResponse, err error) {
	ch := make(chan *ValidatorApiValidateTransactionBatchResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 12

	c.nextValidateTransactionBatchMu.Lock()
	c.nextValidateTransactionBatch += 1
	id := c.nextValidateTransactionBatch
	c.nextValidateTransactionBatchMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightValidateTransactionBatchMu.Lock()
	c.inflightValidateTransactionBatch[id] = ch
	c.inflightValidateTransactionBatchMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightValidateTransactionBatchMu.Lock()
	delete(c.inflightValidateTransactionBatch, id)
	c.inflightValidateTransactionBatchMu.Unlock()
	packet.Put(p)
	return
}

func (c *subValidatorAPIClient) ValidateTransactionStream(ctx context.Context, req *ValidatorApiValidateTransactionRequest) (*ValidateTransactionStreamClient, error) {
	p := packet.Get()

	c.nextStreamingIDMu.Lock()
	c.nextStreamingID += 1
	id := c.nextStreamingID
	c.nextStreamingIDMu.Unlock()

	open := &RPCStreamOpen{operation: 13}

	open.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))

	fStream := c.client.Stream(id)
	fStream.WritePacket(p)

	if req != nil {
		p2 := packet.Get()
		req.Encode(p2.Content)
		p2.Metadata.ContentLength = uint32(len(*p2.Content))
		fStream.WritePacket(p2)
	}

	stream := ValidateTransactionStreamClient{
		context: ctx,
		stream:  fStream,
		closed:  atomic.NewBool(false),
	}

	stream.recv = func() (*ValidatorApiValidateTransactionResponse, error) {
		p, err := stream.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewValidatorApiValidateTransactionResponse()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}

	stream.close = func() {
		stream.stream.Close()
	}
	stream.send = func(m *ValidatorApiValidateTransactionRequest) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return stream.stream.WritePacket(p)
	}
	return &stream, nil
}

type ValidateTransactionStreamClient struct {
	context context.Context
	recv    func() (*ValidatorApiValidateTransactionResponse, error)
	close   func()
	closed  *atomic.Bool

	stream *frisbee.Stream
	send   func(*ValidatorApiValidateTransactionRequest) error
}

func (x *ValidateTransactionStreamClient) Send(m *ValidatorApiValidateTransactionRequest) error {
	return x.send(m)
}

func (x *ValidateTransactionStreamClient) CloseSend() error {
	return x.send(&ValidatorApiValidateTransactionRequest{error: io.EOF})
}

func (x *ValidateTransactionStreamClient) CloseAndRecv() (*ValidatorApiValidateTransactionResponse, error) {
	err := x.send(&ValidatorApiValidateTransactionRequest{error: io.EOF})
	if err != nil {
		return nil, err
	}
	return x.recv()
}

func (c *subValidatorAPIClient) GetBlockHeight(ctx context.Context, req *ValidatorApiEmptyMessage) (res *ValidatorApiGetBlockHeightResponse, err error) {
	ch := make(chan *ValidatorApiGetBlockHeightResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 14

	c.nextGetBlockHeightMu.Lock()
	c.nextGetBlockHeight += 1
	id := c.nextGetBlockHeight
	c.nextGetBlockHeightMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightGetBlockHeightMu.Lock()
	c.inflightGetBlockHeight[id] = ch
	c.inflightGetBlockHeightMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightGetBlockHeightMu.Lock()
	delete(c.inflightGetBlockHeight, id)
	c.inflightGetBlockHeightMu.Unlock()
	packet.Put(p)
	return
}

func (c *subValidatorAPIClient) Subscribe(ctx context.Context, req *ValidatorApiSubscribeRequest) (*SubscribeClient, error) {
	p := packet.Get()

	c.nextStreamingIDMu.Lock()
	c.nextStreamingID += 1
	id := c.nextStreamingID
	c.nextStreamingIDMu.Unlock()

	open := &RPCStreamOpen{operation: 15}

	open.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))

	fStream := c.client.Stream(id)
	fStream.WritePacket(p)

	if req != nil {
		p2 := packet.Get()
		req.Encode(p2.Content)
		p2.Metadata.ContentLength = uint32(len(*p2.Content))
		fStream.WritePacket(p2)
	}

	stream := SubscribeClient{
		context: ctx,
		stream:  fStream,
		closed:  atomic.NewBool(false),
	}

	stream.recv = func() (*ValidatorApiRejectedTxNotification, error) {
		p, err := stream.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewValidatorApiRejectedTxNotification()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}

	stream.close = func() {
		stream.stream.Close()
	}
	stream.send = func(m *ValidatorApiSubscribeRequest) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return stream.stream.WritePacket(p)
	}
	return &stream, nil
}

type SubscribeClient struct {
	context context.Context
	recv    func() (*ValidatorApiRejectedTxNotification, error)
	close   func()
	closed  *atomic.Bool

	stream *frisbee.Stream
	send   func(*ValidatorApiSubscribeRequest) error
}

func (x *SubscribeClient) Recv() (*ValidatorApiRejectedTxNotification, error) {
	return x.recv()
}

type CloseError struct {
	err error
}

func NewCloseError(err error) CloseError {
	return CloseError{err: err}
}

func (e CloseError) Error() string {
	return e.err.Error()
}
