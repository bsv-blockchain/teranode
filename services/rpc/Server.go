package rpc

import (
	"context"
	"crypto/sha256"
	"crypto/subtle"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/bitcoin-sv/teranode/errors"
	"github.com/bitcoin-sv/teranode/services/blockassembly"
	"github.com/bitcoin-sv/teranode/services/blockchain"
	"github.com/bitcoin-sv/teranode/services/legacy/peer"
	"github.com/bitcoin-sv/teranode/services/p2p"
	"github.com/bitcoin-sv/teranode/services/rpc/bsvjson"
	"github.com/bitcoin-sv/teranode/settings"
	"github.com/bitcoin-sv/teranode/ulogger"
	"github.com/bitcoin-sv/teranode/util/health"
	"github.com/ordishs/gocore"
)

// API version constants
const (
	jsonrpcSemverString = "1.3.0"
	jsonrpcSemverMajor  = 1
	jsonrpcSemverMinor  = 3
	jsonrpcSemverPatch  = 0
)

const (
	// rpcAuthTimeoutSeconds is the number of seconds a connection to the
	// RPC server is allowed to stay open without authenticating before it
	// is closed.
	rpcAuthTimeoutSeconds = 10

	// uint256Size is the number of bytes needed to represent an unsigned
	// 256-bit integer.
	// uint256Size = 32

	// gbtNonceRange is two 32-bit big-endian hexadecimal integers which
	// represent the valid ranges of nonces returned by the getblocktemplate
	// RPC.
	// gbtNonceRange = "00000000ffffffff"

	// gbtRegenerateSeconds is the number of seconds that must pass before
	// a new template is generated when the previous block hash has not
	// changed and there have been changes to the available transactions
	// in the memory pool.
	// gbtRegenerateSeconds = 60

	// maxProtocolVersion is the max protocol version the server supports.
	// maxProtocolVersion = wire.FeeFilterVersion
)

var RPCStat = gocore.NewStat("RPC")

var (
// gbtMutableFields are the manipulations the server allows to be made
// to block templates generated by the getblocktemplate RPC.  It is
// declared here to avoid the overhead of creating the slice on every
// invocation for constant data.
// gbtMutableFields = []string{
// 	"time", "transactions/add", "prevblock", "coinbase/append",
// }

// gbtCapabilities describes additional capabilities returned with a
// block template generated by the getblocktemplate RPC.    It is
// declared here to avoid the overhead of creating the slice on every
// invocation for constant data.
// gbtCapabilities = []string{"proposal"}
)

// Errors
var (
	// ErrRPCUnimplemented is an error returned to RPC clients when the
	// provided command is recognized, but not implemented.
	ErrRPCUnimplemented = &bsvjson.RPCError{
		Code:    bsvjson.ErrRPCUnimplemented,
		Message: "Command unimplemented",
	}

	// ErrRPCNoWallet is an error returned to RPC clients when the provided
	// command is recognized as a wallet command.
	ErrRPCNoWallet = &bsvjson.RPCError{
		Code:    bsvjson.ErrRPCNoWallet,
		Message: "This implementation does not implement wallet commands",
	}
)

type commandHandler func(context.Context, *RPCServer, interface{}, <-chan struct{}) (interface{}, error)

// rpcHandlers maps RPC command strings to appropriate handler functions.
// This is set by init because help references rpcHandlers and thus causes
// a dependency loop.
var rpcHandlers map[string]commandHandler
var rpcHandlersBeforeInit = map[string]commandHandler{
	"addnode":               handleUnimplemented,
	"createrawtransaction":  handleCreateRawTransaction,
	"debuglevel":            handleUnimplemented,
	"decoderawtransaction":  handleUnimplemented,
	"decodescript":          handleUnimplemented,
	"estimatefee":           handleUnimplemented,
	"generate":              handleGenerate,
	"generatetoaddress":     handleGenerateToAddress,
	"getaddednodeinfo":      handleUnimplemented,
	"getbestblock":          handleUnimplemented,
	"getbestblockhash":      handleGetBestBlockHash,
	"getblock":              handleGetBlock,
	"getblockbyheight":      handleGetBlockByHeight,
	"getblockchaininfo":     handleGetblockchaininfo,
	"getblockcount":         handleUnimplemented,
	"getblockhash":          handleGetBlockHash,
	"getblockheader":        handleGetBlockHeader,
	"getblocktemplate":      handleUnimplemented,
	"getcfilter":            handleUnimplemented,
	"getcfilterheader":      handleUnimplemented,
	"getconnectioncount":    handleUnimplemented,
	"getcurrentnet":         handleUnimplemented,
	"getdifficulty":         handleGetDifficulty,
	"getgenerate":           handleUnimplemented,
	"gethashespersec":       handleUnimplemented,
	"getheaders":            handleUnimplemented,
	"getinfo":               handleGetInfo,
	"getmempoolinfo":        handleUnimplemented,
	"getmininginfo":         handleGetMiningInfo,
	"getnettotals":          handleUnimplemented,
	"getnetworkhashps":      handleUnimplemented,
	"getpeerinfo":           handleGetpeerinfo,
	"getrawmempool":         handleUnimplemented,
	"getrawtransaction":     handleGetRawTransaction,
	"gettxout":              handleUnimplemented,
	"gettxoutproof":         handleUnimplemented,
	"help":                  handleHelp,
	"node":                  handleUnimplemented,
	"ping":                  handleUnimplemented,
	"invalidateblock":       handleInvalidateBlock,
	"reconsiderblock":       handleReconsiderBlock,
	"searchrawtransactions": handleUnimplemented,
	"sendrawtransaction":    handleSendRawTransaction,
	"setban":                handleSetBan,
	"setgenerate":           handleUnimplemented,
	"stop":                  handleStop,
	"submitblock":           handleUnimplemented,
	"uptime":                handleUnimplemented,
	"validateaddress":       handleUnimplemented,
	"verifychain":           handleUnimplemented,
	"verifymessage":         handleUnimplemented,
	"verifytxoutproof":      handleUnimplemented,
	"version":               handleVersion,
	// BSV mining methods
	"getminingcandidate":   handleGetMiningCandidate,
	"submitminingsolution": handleSubmitMiningSolution,
}

// list of commands that we recognize, but for which bsvd has no support because
// it lacks support for wallet functionality. For these commands the user
// should ask a connected instance of bsvwallet.
var rpcAskWallet = map[string]struct{}{
	"addmultisigaddress":     {},
	"backupwallet":           {},
	"createencryptedwallet":  {},
	"createmultisig":         {},
	"dumpprivkey":            {},
	"dumpwallet":             {},
	"encryptwallet":          {},
	"getaccount":             {},
	"getaccountaddress":      {},
	"getaddressesbyaccount":  {},
	"getbalance":             {},
	"getnewaddress":          {},
	"getrawchangeaddress":    {},
	"getreceivedbyaccount":   {},
	"getreceivedbyaddress":   {},
	"gettransaction":         {},
	"gettxoutsetinfo":        {},
	"getunconfirmedbalance":  {},
	"getwalletinfo":          {},
	"importprivkey":          {},
	"importwallet":           {},
	"keypoolrefill":          {},
	"listaccounts":           {},
	"listaddressgroupings":   {},
	"listlockunspent":        {},
	"listreceivedbyaccount":  {},
	"listreceivedbyaddress":  {},
	"listsinceblock":         {},
	"listtransactions":       {},
	"listunspent":            {},
	"lockunspent":            {},
	"move":                   {},
	"sendfrom":               {},
	"sendmany":               {},
	"sendtoaddress":          {},
	"setaccount":             {},
	"settxfee":               {},
	"signmessage":            {},
	"signrawtransaction":     {},
	"walletlock":             {},
	"walletpassphrase":       {},
	"walletpassphrasechange": {},
}

// Commands that are currently unimplemented, but should ultimately be.
var rpcUnimplemented = map[string]struct{}{
	"estimatepriority": {},
	"getchaintips":     {},
	"getmempoolentry":  {},
	"getnetworkinfo":   {},
	"getwork":          {},
	// "invalidateblock":  {},
	"preciousblock": {},
}

// Commands that are available to a limited user
var rpcLimited = map[string]struct{}{
	// Websockets commands
	"loadtxfilter":          {},
	"notifyblocks":          {},
	"notifynewtransactions": {},
	"notifyreceived":        {},
	"notifyspent":           {},
	"rescan":                {},
	"rescanblocks":          {},
	"session":               {},

	// Websockets AND HTTP/S commands
	"help": {},

	// HTTP/S-only commands
	"createrawtransaction":  {},
	"decoderawtransaction":  {},
	"decodescript":          {},
	"estimatefee":           {},
	"getbestblock":          {},
	"getbestblockhash":      {},
	"getblock":              {},
	"getblockcount":         {},
	"getblockhash":          {},
	"getblockheader":        {},
	"getcfilter":            {},
	"getcfilterheader":      {},
	"getcurrentnet":         {},
	"getdifficulty":         {},
	"getheaders":            {},
	"getinfo":               {},
	"getnettotals":          {},
	"getnetworkhashps":      {},
	"getrawmempool":         {},
	"getrawtransaction":     {},
	"gettxout":              {},
	"gettxoutproof":         {},
	"searchrawtransactions": {},
	"sendrawtransaction":    {},
	"submitblock":           {},
	"uptime":                {},
	"validateaddress":       {},
	"verifymessage":         {},
	"verifytxoutproof":      {},
	"version":               {},
	"getminingcandidate":    {},
	"submitminingsolution":  {},
}

// builderScript is a convenience function which is used for hard-coded scripts
// built with the script builder.   Any errors are converted to a panic since it
// is only, and must only, be used with hard-coded, and therefore, known good,
// scripts.
// func builderScript(builder *txscript.ScriptBuilder) []byte {
// 	script, err := builder.Script()
// 	if err != nil {
// 		panic(err)
// 	}
// 	return script
// }

// internalRPCError is a convenience function to convert an internal error to
// an RPC error with the appropriate code set.  It also logs the error to the
// RPC server subsystem since internal errors really should not occur.  The
// context parameter is only used in the log message and may be empty if it's
// not needed.
func internalRPCError(errStr, context string) *bsvjson.RPCError {
	logStr := errStr
	if context != "" {
		logStr = context + ": " + errStr
	}

	fmt.Print(logStr)

	return bsvjson.NewRPCError(bsvjson.ErrRPCInternal.Code, errStr)
}

// rpcDecodeHexError is a convenience function for returning a nicely formatted
// RPC error which indicates the provided hex string failed to decode.
func rpcDecodeHexError(gotHex string) *bsvjson.RPCError {
	return bsvjson.NewRPCError(bsvjson.ErrRPCDecodeHexString,
		fmt.Sprintf("Argument must be hexadecimal string (not %q)",
			gotHex))
}

// rpcNoTxInfoError is a convenience function for returning a nicely formatted
// RPC error which indicates there is no information available for the provided
// transaction hash.
// func rpcNoTxInfoError(txHash *chainhash.Hash) *bsvjson.RPCError {
// 	return bsvjson.NewRPCError(bsvjson.ErrRPCNoTxInfo,
// 		fmt.Sprintf("No information available about transaction %v",
// 			txHash))
// }

// handleUnimplemented is the handler for commands that should ultimately be
// supported but are not yet implemented.
func handleUnimplemented(ctx context.Context, s *RPCServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	s.logger.Debugf("handling unimplemented command")
	return nil, ErrRPCUnimplemented
}

// handleAskWallet is the handler for commands that are recognized as valid, but
// are unable to answer correctly since it involves wallet state.
// These commands will be implemented in bsvwallet.
func handleAskWallet(ctx context.Context, s *RPCServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	return nil, ErrRPCNoWallet
}

// encodeTemplateID encodes the passed details into an ID that can be used to
// uniquely identify a block template.
// func encodeTemplateID(prevHash *chainhash.Hash, lastGenerated time.Time) string {
// 	return fmt.Sprintf("%s-%d", prevHash.String(), lastGenerated.Unix())
// }

// decodeTemplateID decodes an ID that is used to uniquely identify a block
// template.  This is mainly used as a mechanism to track when to update clients
// that are using long polling for block templates.  The ID consists of the
// previous block hash for the associated template and the time the associated
// template was generated.
// func decodeTemplateID(templateID string) (*chainhash.Hash, int64, error) {
// 	fields := strings.Split(templateID, "-")
// 	if len(fields) != 2 {
// 		return nil, 0, errors.New("invalid longpollid format")
// 	}

// 	prevHash, err := chainhash.NewHashFromStr(fields[0])
// 	if err != nil {
// 		return nil, 0, errors.New("invalid longpollid format")
// 	}
// 	lastGenerated, err := strconv.ParseInt(fields[1], 10, 64)
// 	if err != nil {
// 		return nil, 0, errors.New("invalid longpollid format")
// 	}

// 	return prevHash, lastGenerated, nil
// }

// chainErrToGBTErrString converts an error returned from btcchain to a string
// which matches the reasons and format described in BIP0022 for rejection
// reasons.
// func chainErrToGBTErrString(err error) string {
// 	// When the passed error is not a RuleError, just return a generic
// 	// rejected string with the error text.
// 	ruleErr, ok := err.(bsvd_blockchain.RuleError)
// 	if !ok {
// 		return "rejected: " + err.Error()
// 	}

// 	switch ruleErr.ErrorCode {
// 	case bsvd_blockchain.ErrDuplicateBlock:
// 		return "duplicate"
// 	case bsvd_blockchain.ErrBlockTooBig:
// 		return "bad-blk-length"
// 	case bsvd_blockchain.ErrBlockVersionTooOld:
// 		return "bad-version"
// 	case bsvd_blockchain.ErrInvalidTime:
// 		return "bad-time"
// 	case bsvd_blockchain.ErrTimeTooOld:
// 		return "time-too-old"
// 	case bsvd_blockchain.ErrTimeTooNew:
// 		return "time-too-new"
// 	case bsvd_blockchain.ErrDifficultyTooLow:
// 		return "bad-diffbits"
// 	case bsvd_blockchain.ErrUnexpectedDifficulty:
// 		return "bad-diffbits"
// 	case bsvd_blockchain.ErrHighHash:
// 		return "high-hash"
// 	case bsvd_blockchain.ErrBadMerkleRoot:
// 		return "bad-txnmrklroot"
// 	case bsvd_blockchain.ErrBadCheckpoint:
// 		return "bad-checkpoint"
// 	case bsvd_blockchain.ErrForkTooOld:
// 		return "fork-too-old"
// 	case bsvd_blockchain.ErrCheckpointTimeTooOld:
// 		return "checkpoint-time-too-old"
// 	case bsvd_blockchain.ErrNoTransactions:
// 		return "bad-txns-none"
// 	case bsvd_blockchain.ErrNoTxInputs:
// 		return "bad-txns-noinputs"
// 	case bsvd_blockchain.ErrNoTxOutputs:
// 		return "bad-txns-nooutputs"
// 	case bsvd_blockchain.ErrTxTooBig:
// 		return "bad-txns-size-too-large"
// 	case bsvd_blockchain.ErrTxTooSmall:
// 		return "bad-txns-size-too-small"
// 	case bsvd_blockchain.ErrTxTooManySigOps:
// 		return "bad-txns-too-many-sigops"
// 	case bsvd_blockchain.ErrBadTxOutValue:
// 		return "bad-txns-outputvalue"
// 	case bsvd_blockchain.ErrDuplicateTxInputs:
// 		return "bad-txns-dupinputs"
// 	case bsvd_blockchain.ErrBadTxInput:
// 		return "bad-txns-badinput"
// 	case bsvd_blockchain.ErrMissingTxOut:
// 		return "bad-txns-missinginput"
// 	case bsvd_blockchain.ErrSpentTxOut:
// 		return "bad-txns-spentinput"
// 	case bsvd_blockchain.ErrUnfinalizedTx:
// 		return "bad-txns-unfinalizedtx"
// 	case bsvd_blockchain.ErrDuplicateTx:
// 		return "bad-txns-duplicate"
// 	case bsvd_blockchain.ErrOverwriteTx:
// 		return "bad-txns-overwrite"
// 	case bsvd_blockchain.ErrImmatureSpend:
// 		return "bad-txns-maturity"
// 	case bsvd_blockchain.ErrSpendTooHigh:
// 		return "bad-txns-highspend"
// 	case bsvd_blockchain.ErrBadFees:
// 		return "bad-txns-fees"
// 	case bsvd_blockchain.ErrTooManySigOps:
// 		return "high-sigops"
// 	case bsvd_blockchain.ErrFirstTxNotCoinbase:
// 		return "bad-txns-nocoinbase"
// 	case bsvd_blockchain.ErrMultipleCoinbases:
// 		return "bad-txns-multicoinbase"
// 	case bsvd_blockchain.ErrBadCoinbaseScriptLen:
// 		return "bad-cb-length"
// 	case bsvd_blockchain.ErrBadCoinbaseValue:
// 		return "bad-cb-value"
// 	case bsvd_blockchain.ErrMissingCoinbaseHeight:
// 		return "bad-cb-height"
// 	case bsvd_blockchain.ErrBadCoinbaseHeight:
// 		return "bad-cb-height"
// 	case bsvd_blockchain.ErrScriptMalformed:
// 		return "bad-script-malformed"
// 	case bsvd_blockchain.ErrScriptValidation:
// 		return "bad-script-validate"
// 	case bsvd_blockchain.ErrPreviousBlockUnknown:
// 		return "prev-blk-not-found"
// 	case bsvd_blockchain.ErrInvalidAncestorBlock:
// 		return "bad-prevblk"
// 	case bsvd_blockchain.ErrPrevBlockNotBest:
// 		return "inconclusive-not-best-prvblk"
// 	case bsvd_blockchain.ErrInvalidTxOrder:
// 		return "invalid-transaction-order"
// 	}

// 	return "rejected: " + err.Error()
// }

// handleHelp implements the help command.
// func handleHelp(s *rpcServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
// 	c := cmd.(*bsvjson.HelpCmd)

// 	// Provide a usage overview of all commands when no specific command
// 	// was specified.
// 	var command string
// 	if c.Command != nil {
// 		command = *c.Command
// 	}
// 	if command == "" {
// 		s.logger.Errorf("no command specified")
// 		// usage, err := s.helpCacher.rpcUsage(false)
// 		// 	if err != nil {
// 		// 		context := "Failed to generate RPC usage"
// 		// 		return nil, internalRPCError(err.Error(), context)
// 		// 	}
// 		// return usage, nil
// 	}

// 	// Check that the command asked for is supported and implemented.  Only
// 	// search the main list of handlers since help should not be provided
// 	// for commands that are unimplemented or related to wallet
// 	// functionality.
// 	if _, ok := rpcHandlers[command]; !ok {
// 		return nil, &bsvjson.RPCError{
// 			Code:    bsvjson.ErrRPCInvalidParameter,
// 			Message: "Unknown command: " + command,
// 		}
// 	}

// 	// Get the help for the command.
// 	// help, err := s.helpCacher.rpcMethodHelp(command)
// 	// if err != nil {
// 	// 	context := "Failed to generate help"
// 	// 	return nil, internalRPCError(err.Error(), context)
// 	// }
// 	return nil, nil
// }

// handleStop implements the stop command.
func handleStop(_ context.Context, s *RPCServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	select {
	case s.requestProcessShutdown <- struct{}{}:
	default:
	}

	return "bsvd stopping.", nil
}

// handleVersion implements the version command.
//
// NOTE: This is a btcsuite extension ported from github.com/decred/dcrd.
func handleVersion(_ context.Context, s *RPCServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	result := map[string]bsvjson.VersionResult{
		"btcdjsonrpcapi": {
			VersionString: jsonrpcSemverString,
			Major:         jsonrpcSemverMajor,
			Minor:         jsonrpcSemverMinor,
			Patch:         jsonrpcSemverPatch,
		},
	}

	return result, nil
}

// RPCServer provides a concurrent safe RPC server to a chain server.
type RPCServer struct {
	settings               *settings.Settings
	started                int32
	shutdown               int32
	authsha                [sha256.Size]byte
	limitauthsha           [sha256.Size]byte
	numClients             int32
	statusLines            map[int]string
	statusLock             sync.RWMutex
	wg                     sync.WaitGroup
	requestProcessShutdown chan struct{}
	quit                   chan int
	logger                 ulogger.Logger
	rpcMaxClients          int
	rpcQuirks              bool
	listeners              []net.Listener
	blockchainClient       blockchain.ClientI
	blockAssemblyClient    *blockassembly.Client
	peerClient             peer.ClientI
	p2pClient              p2p.ClientI
	assetHTTPURL           *url.URL
	helpCacher             *helpCacher
}

// httpStatusLine returns a response Status-Line (RFC 2616 Section 6.1)
// for the given request and response status code.  This function was lifted and
// adapted from the standard library HTTP server code since it's not exported.
func (s *RPCServer) httpStatusLine(req *http.Request, code int) string {
	// Fast path:
	key := code
	proto11 := req.ProtoAtLeast(1, 1)

	if !proto11 {
		key = -key
	}

	s.statusLock.RLock()
	line, ok := s.statusLines[key]
	s.statusLock.RUnlock()

	if ok {
		return line
	}

	// Slow path:
	proto := "HTTP/1.0"
	if proto11 {
		proto = "HTTP/1.1"
	}

	codeStr := strconv.Itoa(code)
	text := http.StatusText(code)

	if text != "" {
		line = proto + " " + codeStr + " " + text + "\r\n"

		s.statusLock.Lock()
		s.statusLines[key] = line
		s.statusLock.Unlock()
	} else {
		text = "status code " + codeStr
		line = proto + " " + codeStr + " " + text + "\r\n"
	}

	return line
}

// writeHTTPResponseHeaders writes the necessary response headers prior to
// writing an HTTP body given a request to use for protocol negotiation, headers
// to write, a status code, and a writer.
func (s *RPCServer) writeHTTPResponseHeaders(req *http.Request, headers http.Header, code int, w io.Writer) error {
	_, err := io.WriteString(w, s.httpStatusLine(req, code))
	if err != nil {
		return err
	}

	err = headers.Write(w)
	if err != nil {
		return err
	}

	_, err = io.WriteString(w, "\r\n")

	return err
}

// Stop is used by server.go to stop the rpc listener.
func (s *RPCServer) Stop(ctx context.Context) error {
	if atomic.AddInt32(&s.shutdown, 1) != 1 {
		s.logger.Infof("RPC server is already in the process of shutting down")
		return nil
	}

	s.logger.Warnf("RPC server shutting down")

	close(s.quit)
	s.wg.Wait()
	s.logger.Infof("RPC server shutdown complete")

	return nil
}

// RequestedProcessShutdown returns a channel that is sent to when an authorized
// RPC client requests the process to shutdown.  If the request can not be read
// immediately, it is dropped.
func (s *RPCServer) RequestedProcessShutdown() <-chan struct{} {
	return s.requestProcessShutdown
}

// limitConnections responds with a 503 service unavailable and returns true if
// adding another client would exceed the maximum allow RPC clients.
//
// This function is safe for concurrent access.
func (s *RPCServer) limitConnections(w http.ResponseWriter, remoteAddr string) bool {
	if int(atomic.LoadInt32(&s.numClients)+1) > s.rpcMaxClients {
		s.logger.Infof("Max RPC clients exceeded [%d] - "+
			"disconnecting client %s", s.rpcMaxClients,
			remoteAddr)
		http.Error(w, "503 Too busy.  Try again later.",
			http.StatusServiceUnavailable)

		return true
	}

	return false
}

// incrementClients adds one to the number of connected RPC clients.  Note
// this only applies to standard clients.  Websocket clients have their own
// limits and are tracked separately.
//
// This function is safe for concurrent access.
func (s *RPCServer) incrementClients() {
	atomic.AddInt32(&s.numClients, 1)
}

// decrementClients subtracts one from the number of connected RPC clients.
// Note this only applies to standard clients.  Websocket clients have their own
// limits and are tracked separately.
//
// This function is safe for concurrent access.
func (s *RPCServer) decrementClients() {
	atomic.AddInt32(&s.numClients, -1)
}

// checkAuth checks the HTTP Basic authentication supplied by a wallet
// or RPC client in the HTTP request r.  If the supplied authentication
// does not match the username and password expected, a non-nil error is
// returned.
//
// This check is time-constant.
//
// The first bool return value signifies auth success (true if successful) and
// the second bool return value specifies whether the user can change the state
// of the server (true) or whether the user is limited (false). The second is
// always false if the first is.
func (s *RPCServer) checkAuth(r *http.Request, require bool) (bool, bool, error) {
	authhdr := r.Header["Authorization"]

	if len(authhdr) == 0 {
		if require {
			s.logger.Warnf("RPC authentication failure from %s", r.RemoteAddr)
			return false, false, errors.NewServiceError("auth failure")
		}

		return false, false, nil
	}

	authsha := sha256.Sum256([]byte(authhdr[0]))

	// Check for limited auth first as in environments with limited users, those
	// are probably expected to have a higher volume of calls
	limitcmp := subtle.ConstantTimeCompare(authsha[:], s.limitauthsha[:])
	if limitcmp == 1 {
		return true, false, nil
	}

	// Check for admin-level auth
	cmp := subtle.ConstantTimeCompare(authsha[:], s.authsha[:])
	if cmp == 1 {
		return true, true, nil
	}

	// Request's auth doesn't match either user
	s.logger.Warnf("RPC authentication failure from %s", r.RemoteAddr)

	return false, false, errors.NewServiceError("auth failure")
}

// parsedRPCCmd represents a JSON-RPC request object that has been parsed into
// a known concrete command along with any error that might have happened while
// parsing it.
type parsedRPCCmd struct {
	id     interface{}
	method string
	cmd    interface{}
	err    *bsvjson.RPCError
}

// standardCmdResult checks that a parsed command is a standard Bitcoin JSON-RPC
// command and runs the appropriate handler to reply to the command.  Any
// commands which are not recognized or not implemented will return an error
// suitable for use in replies.
func (s *RPCServer) standardCmdResult(ctx context.Context, cmd *parsedRPCCmd, closeChan <-chan struct{}) (interface{}, error) {
	handler, ok := rpcHandlers[cmd.method]
	if ok {
		goto handled
	}

	_, ok = rpcAskWallet[cmd.method]

	if ok {
		handler = handleAskWallet
		goto handled
	}

	_, ok = rpcUnimplemented[cmd.method]
	if ok {
		handler = handleUnimplemented
		goto handled
	}

	return nil, bsvjson.ErrRPCMethodNotFound
handled:

	return handler(ctx, s, cmd.cmd, closeChan)
}

// parseCmd parses a JSON-RPC request object into known concrete command.  The
// err field of the returned parsedRPCCmd struct will contain an RPC error that
// is suitable for use in replies if the command is invalid in some way such as
// an unregistered command or invalid parameters.
func parseCmd(request *bsvjson.Request) *parsedRPCCmd {
	var parsedCmd parsedRPCCmd
	parsedCmd.id = request.ID
	parsedCmd.method = request.Method

	cmd, err := bsvjson.UnmarshalCmd(request)
	if err != nil {
		fmt.Printf("Error unmarshalling command: %v", err)
		// When the error is because the method is not registered,
		// produce a method not found RPC error.
		if jerr, ok := err.(bsvjson.Error); ok &&
			jerr.ErrorCode == bsvjson.ErrUnregisteredMethod {
			parsedCmd.err = bsvjson.ErrRPCMethodNotFound
			return &parsedCmd
		}

		// Otherwise, some type of invalid parameters is the
		// cause, so produce the equivalent RPC error.
		parsedCmd.err = bsvjson.NewRPCError(
			bsvjson.ErrRPCInvalidParams.Code, err.Error())

		return &parsedCmd
	}

	parsedCmd.cmd = cmd

	return &parsedCmd
}

// createMarshalledReply returns a new marshalled JSON-RPC response given the
// passed parameters.  It will automatically convert errors that are not of
// the type *bsvjson.RPCError to the appropriate type as needed.
func createMarshalledReply(id, result interface{}, replyErr error) ([]byte, error) {
	var jsonErr *bsvjson.RPCError

	if replyErr != nil {
		if jErr, ok := replyErr.(*bsvjson.RPCError); ok {
			jsonErr = jErr
		} else {
			jsonErr = internalRPCError(replyErr.Error(), "")
		}
	}

	return bsvjson.MarshalResponse(id, result, jsonErr)
}

// jsonRPCRead handles reading and responding to RPC messages.
func (s *RPCServer) jsonRPCRead(w http.ResponseWriter, r *http.Request, isAdmin bool) {
	if atomic.LoadInt32(&s.shutdown) != 0 {
		return
	}

	// Read and close the JSON-RPC request body from the caller.
	body, err := io.ReadAll(r.Body)
	_ = r.Body.Close()

	if err != nil {
		errCode := http.StatusBadRequest
		http.Error(w, fmt.Sprintf("%d error reading JSON message: %v",
			errCode, err), errCode)

		return
	}

	s.logger.Debugf("jsonRPCRead body: %s", body)

	// Unfortunately, the http server doesn't provide the ability to
	// change the read deadline for the new connection and having one breaks
	// long polling.  However, not having a read deadline on the initial
	// connection would mean clients can connect and idle forever.  Thus,
	// hijack the connecton from the HTTP server, clear the read deadline,
	// and handle writing the response manually.
	hj, ok := w.(http.Hijacker)
	if !ok {
		errMsg := "webserver doesn't support hijacking"
		s.logger.Warnf(errMsg)

		errCode := http.StatusInternalServerError
		http.Error(w, strconv.Itoa(errCode)+" "+errMsg, errCode)

		return
	}

	conn, buf, err := hj.Hijack()

	if err != nil {
		s.logger.Warnf("Failed to hijack HTTP connection: %v", err)

		errCode := http.StatusInternalServerError

		http.Error(w, strconv.Itoa(errCode)+" "+err.Error(), errCode)

		return
	}

	defer conn.Close()
	defer buf.Flush()
	// conn.SetReadDeadline(timeZeroVal)

	// Attempt to parse the raw body into a JSON-RPC request.
	var responseID interface{}

	var jsonErr error

	var result interface{}

	var request bsvjson.Request

	if err := json.Unmarshal(body, &request); err != nil {
		jsonErr = &bsvjson.RPCError{
			Code:    bsvjson.ErrRPCParse.Code,
			Message: "Failed to parse request: " + err.Error(),
		}
	}

	if jsonErr == nil {
		// The JSON-RPC 1.0 spec defines that notifications must have their "id"
		// set to null and states that notifications do not have a response.
		//
		// A JSON-RPC 2.0 notification is a request with "json-rpc":"2.0", and
		// without an "id" member. The specification states that notifications
		// must not be responded to. JSON-RPC 2.0 permits the null value as a
		// valid request id, therefore such requests are not notifications.
		//
		// Bitcoin Core serves requests with "id":null or even an absent "id",
		// and responds to such requests with "id":null in the response.
		//
		// Bsvd does not respond to any request without and "id" or "id":null,
		// regardless the indicated JSON-RPC protocol version unless RPC quirks
		// are enabled. With RPC quirks enabled, such requests will be responded
		// to if the reqeust does not indicate JSON-RPC version.
		//
		// RPC quirks can be enabled by the user to avoid compatibility issues
		// with software relying on Core's behavior.
		if request.ID == nil && !(s.rpcQuirks && request.Jsonrpc == "") {
			s.logger.Debugf("request id:%d, rpsQuirks: %t", request.ID, s.rpcQuirks) //

			return
		}

		// The parse was at least successful enough to have an ID so
		// set it for the response.
		responseID = request.ID

		// Setup a close notifier.  Since the connection is hijacked,
		// the CloseNotifer on the ResponseWriter is not available.
		closeChan := make(chan struct{}, 1)

		go func() {
			_, err := conn.Read(make([]byte, 1))
			if err != nil {
				close(closeChan)
			}
		}()

		// Check if the user is limited and set error if method unauthorized
		if !isAdmin {
			if _, ok := rpcLimited[request.Method]; !ok {
				jsonErr = &bsvjson.RPCError{
					Code:    bsvjson.ErrRPCInvalidParams.Code,
					Message: "limited user not authorized for this method",
				}
			}
		}

		if jsonErr == nil {
			// Attempt to parse the JSON-RPC request into a known concrete
			// command.
			parsedCmd := parseCmd(&request)
			if parsedCmd.err != nil {
				jsonErr = parsedCmd.err
			} else {
				result, jsonErr = s.standardCmdResult(r.Context(), parsedCmd, closeChan)
			}
		}
	}

	// Marshal the response.
	msg, err := createMarshalledReply(responseID, result, jsonErr)
	if err != nil {
		s.logger.Errorf("Failed to marshal reply: %v", err)
		return
	}

	// Write the response.
	err = s.writeHTTPResponseHeaders(r, w.Header(), http.StatusOK, buf)
	if err != nil {
		s.logger.Errorf("Error writing HTTPResponseHeaders: %v", err)
		return
	}

	if _, err := buf.Write(msg); err != nil {
		s.logger.Errorf("Failed to write marshalled reply: %v", err)
	}

	// Terminate with newline to maintain compatibility with Bitcoin Core.
	if err := buf.WriteByte('\n'); err != nil {
		s.logger.Errorf("Failed to append terminating newline to reply: %v", err)
	}
}

// jsonAuthFail sends a message back to the client if the http auth is rejected.
func jsonAuthFail(w http.ResponseWriter) {
	w.Header().Add("WWW-Authenticate", `Basic realm="bsvd RPC"`)
	http.Error(w, "401 Unauthorized.", http.StatusUnauthorized)
}

// Start is used by server.go to start the rpc listener.
func (s *RPCServer) Start(ctx context.Context, readyCh chan<- struct{}) error {
	var closeOnce sync.Once
	defer closeOnce.Do(func() { close(readyCh) })

	// Blocks until the FSM transitions from the IDLE state
	err := s.blockchainClient.WaitUntilFSMTransitionFromIdleState(ctx)
	if err != nil {
		s.logger.Errorf("[RPC Service] Failed to wait for FSM transition from IDLE state: %s", err)

		return err
	}

	if atomic.AddInt32(&s.started, 1) != 1 {
		return nil
	}

	// TODO (GOKHAN): Discuss if we need to restore the node before starting the RPC server
	// Currently we are starting the RPC server even if we are in the RESTORE mode
	/*
		// Check if we need to Restore. If so, move FSM to the Restore state
		// Restore will block and wait for RUN event to be manually sent
		// TODO: think if we can automate transition to RUN state after restore is complete.
		if s.settings.BlockChain.FSMStateRestore {
			// Send Restore event to FSM
			_, err := s.blockchainClient.Restore(ctx, &emptypb.Empty{})
			if err != nil {
				v.logger.Errorf("[RPC] failed to send Restore event [%v], this should not happen, FSM will continue without Restoring", err)
			}

			// Wait for node to finish Restoring.
			// this means FSM got a RUN event and transitioned to RUN state
			// this will block
			s.logger.Infof("[RPC] Node is restoring, waiting for FSM to transition to Running state")
			_ = s.blockchainClient.WaitForFSMtoTransitionToGivenState(ctx, blockchain_api.FSMStateType_RUNNING)
			s.logger.Infof("[RPC] Node finished restoring and has transitioned to Running state, continuing to start Asset service")
		}
	*/

	s.logger.Infof("Starting RPC server")

	rpcServeMux := http.NewServeMux()
	httpServer := &http.Server{
		Handler: rpcServeMux,

		// Timeout connections which don't complete the initial
		// handshake within the allowed timeframe.
		ReadTimeout: time.Second * rpcAuthTimeoutSeconds,
	}

	rpcServeMux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Connection", "close")
		w.Header().Set("Content-Type", "application/json")

		r.Close = true

		// Limit the number of connections to max allowed.
		if s.limitConnections(w, r.RemoteAddr) {
			return
		}

		// Keep track of the number of connected clients.
		s.incrementClients()
		defer s.decrementClients()
		_, isAdmin, err := s.checkAuth(r, true)

		if err != nil {
			jsonAuthFail(w)
			return
		}

		// Read and respond to the request.
		s.jsonRPCRead(w, r, isAdmin)
	})

	for _, listener := range s.listeners {
		s.wg.Add(1)

		go func(listener net.Listener) {
			defer s.wg.Done() // Ensure wg.Done() is called when the goroutine exits.

			// Shutdown logic when context is cancelled
			go func() {
				<-ctx.Done() // Wait for the context to be cancelled.
				s.logger.Infof("Shutting down RPC server on %s", listener.Addr())

				shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second) // 5-second timeout for shutdown
				defer cancel()

				if err := httpServer.Shutdown(shutdownCtx); err != nil {
					s.logger.Errorf("RPC server shutdown error: %v", err)
				}
			}()

			closeOnce.Do(func() { close(readyCh) })

			s.logger.Infof("RPC server listening on %s", listener.Addr())
			_ = httpServer.Serve(listener)
			s.logger.Infof("RPC listener done for %s", listener.Addr())
		}(listener)
	}
	// wait for the server to finish
	<-ctx.Done()
	s.logger.Infof("Main context cancelled. Waiting for servers to complete...")

	// Wait for all servers to complete
	s.wg.Wait()

	s.logger.Infof("All servers have shut down gracefully.")

	return nil
}

func NewServer(logger ulogger.Logger, tSettings *settings.Settings, blockchainClient blockchain.ClientI) (*RPCServer, error) {
	initPrometheusMetrics()

	assetHTTPAddress := tSettings.Asset.HTTPAddress
	if assetHTTPAddress == "" {
		return nil, errors.NewConfigurationError("missing setting: asset_httpAddress")
	}

	parsedURL, err := url.ParseRequestURI(assetHTTPAddress)
	if err != nil {
		return nil, errors.NewConfigurationError("Invalid URL", err)
	}

	rpc := RPCServer{
		statusLines:            make(map[int]string),
		requestProcessShutdown: make(chan struct{}),
		logger:                 logger,
		settings:               tSettings,
		quit:                   make(chan int),
		blockchainClient:       blockchainClient,
		assetHTTPURL:           parsedURL,
		helpCacher:             newHelpCacher(),
	}

	rpcUser := tSettings.RPC.RPCUser
	if rpcUser == "" {
		logger.Warnf("rpc_user not set in config")
	}

	rpcPass := tSettings.RPC.RPCPass
	if rpcPass == "" {
		logger.Warnf("rpc_pass not set in config")
	}

	rpcLimitUser := tSettings.RPC.RPCLimitUser
	if rpcLimitUser == "" {
		logger.Warnf("rpc_limit_user not set in config")
	}

	rpcLimitPass := tSettings.RPC.RPCLimitPass
	if rpcLimitPass == "" {
		logger.Warnf("rpc_limit_pass not set in config")
	}

	if rpcUser != "" && rpcPass != "" {
		login := rpcUser + ":" + rpcPass
		auth := "Basic " + base64.StdEncoding.EncodeToString([]byte(login))
		rpc.authsha = sha256.Sum256([]byte(auth))
	}

	if rpcLimitUser != "" && rpcLimitPass != "" {
		login := rpcLimitUser + ":" + rpcLimitPass
		auth := "Basic " + base64.StdEncoding.EncodeToString([]byte(login))
		rpc.limitauthsha = sha256.Sum256([]byte(auth))
	}
	// rpc.cfg.Chain.Subscribe(rpc.handleBlockchainNotification)

	rpc.rpcMaxClients = tSettings.RPC.RPCMaxClients

	rpc.rpcQuirks = tSettings.RPC.RPCQuirks

	rpcListenerURL := tSettings.RPC.RPCListenerURL
	if rpcListenerURL == "" {
		return nil, errors.NewConfigurationError("rpc_listener_url not set in config")
	}

	listener, err := net.Listen("tcp", rpcListenerURL)
	if err != nil {
		fmt.Println("Error listening:", err)
		os.Exit(1)
	}

	rpc.listeners = append(rpc.listeners, listener)

	return &rpc, nil
}

func (s *RPCServer) Init(ctx context.Context) (err error) {
	rpcHandlers = rpcHandlersBeforeInit
	// rand.Seed(time.Now().UnixNano())
	s.blockAssemblyClient, err = blockassembly.NewClient(ctx, s.logger, s.settings)
	if err != nil {
		return
	}

	s.peerClient, err = peer.NewClient(ctx, s.logger, s.settings)
	if err != nil {
		s.logger.Errorf("error initializing peer client: %v", err)
	}

	s.p2pClient, err = p2p.NewClient(ctx, s.logger, s.settings)
	if err != nil {
		s.logger.Errorf("error initializing p2p client: %v", err)
	}

	return nil
}

func (s *RPCServer) Health(ctx context.Context, checkLiveness bool) (int, string, error) {
	if checkLiveness {
		// Add liveness checks here. Don't include dependency checks.
		// If the service is stuck return http.StatusServiceUnavailable
		// to indicate a restart is needed
		return http.StatusOK, "OK", nil
	}

	// Add readiness checks here. Include dependency checks.
	// If any dependency is not ready, return http.StatusServiceUnavailable
	// If all dependencies are ready, return http.StatusOK
	// A failed dependency check does not imply the service needs restarting
	checks := make([]health.Check, 0, 3)

	if s.blockchainClient != nil {
		checks = append(checks, health.Check{Name: "BlockchainClient", Check: s.blockchainClient.Health})
		checks = append(checks, health.Check{Name: "FSM", Check: blockchain.CheckFSM(s.blockchainClient)})
	}

	if s.blockAssemblyClient != nil {
		checks = append(checks, health.Check{Name: "BlockAssemblyClient", Check: s.blockAssemblyClient.Health})
	}

	return health.CheckAll(ctx, checkLiveness, checks)
}
