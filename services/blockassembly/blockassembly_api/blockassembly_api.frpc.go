// Code generated by fRPC Go v0.7.3, DO NOT EDIT.
// source: services/blockassembly/blockassembly_api/blockassembly_api.proto

package blockassembly_api

import (
	"errors"
	"github.com/loopholelabs/polyglot"
	"net"

	"context"
	"crypto/tls"
	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/rs/zerolog"

	"sync"
)

var (
	ErrNilDecode = errors.New("cannot decode into a nil root struct")
)

type BlockassemblyApiEmptyMessage struct {
	error error
	flags uint8
}

func NewBlockassemblyApiEmptyMessage() *BlockassemblyApiEmptyMessage {
	return &BlockassemblyApiEmptyMessage{}
}

func (x *BlockassemblyApiEmptyMessage) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiEmptyMessage) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *BlockassemblyApiEmptyMessage) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiEmptyMessage) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type BlockassemblyApiHealthResponse struct {
	error error
	flags uint8

	Ok        bool
	Details   string
	Timestamp uint32
}

func NewBlockassemblyApiHealthResponse() *BlockassemblyApiHealthResponse {
	return &BlockassemblyApiHealthResponse{}
}

func (x *BlockassemblyApiHealthResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiHealthResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Ok).String(x.Details).Uint32(x.Timestamp)
	}
}

func (x *BlockassemblyApiHealthResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiHealthResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ok, err = d.Bool()
	if err != nil {
		return err
	}
	x.Details, err = d.String()
	if err != nil {
		return err
	}
	x.Timestamp, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type BlockassemblyApiNewChaintipAndHeightRequest struct {
	error error
	flags uint8

	Chaintip []byte
	Height   uint32
}

func NewBlockassemblyApiNewChaintipAndHeightRequest() *BlockassemblyApiNewChaintipAndHeightRequest {
	return &BlockassemblyApiNewChaintipAndHeightRequest{}
}

func (x *BlockassemblyApiNewChaintipAndHeightRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiNewChaintipAndHeightRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Chaintip).Uint32(x.Height)
	}
}

func (x *BlockassemblyApiNewChaintipAndHeightRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiNewChaintipAndHeightRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Chaintip, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	x.Height, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type BlockassemblyApiAddTxRequest struct {
	error error
	flags uint8

	Txid     []byte
	Fee      uint64
	Size     uint64
	Locktime uint32
	Utxos    [][]byte
}

func NewBlockassemblyApiAddTxRequest() *BlockassemblyApiAddTxRequest {
	return &BlockassemblyApiAddTxRequest{}
}

func (x *BlockassemblyApiAddTxRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiAddTxRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Txid).Uint64(x.Fee).Uint64(x.Size).Uint32(x.Locktime)
		polyglot.Encoder(b).Slice(uint32(len(x.Utxos)), polyglot.BytesKind)
		for _, v := range x.Utxos {
			polyglot.Encoder(b).Bytes(v)
		}
	}
}

func (x *BlockassemblyApiAddTxRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiAddTxRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Txid, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	x.Fee, err = d.Uint64()
	if err != nil {
		return err
	}
	x.Size, err = d.Uint64()
	if err != nil {
		return err
	}
	x.Locktime, err = d.Uint32()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.BytesKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Utxos)) != sliceSize {
		x.Utxos = make([][]byte, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.Utxos[i], err = d.Bytes([]byte{})
		if err != nil {
			return err
		}
	}
	return nil
}

type BlockassemblyApiAddTxBatchRequest struct {
	error error
	flags uint8

	TxRequests []*BlockassemblyApiAddTxRequest
}

func NewBlockassemblyApiAddTxBatchRequest() *BlockassemblyApiAddTxBatchRequest {
	return &BlockassemblyApiAddTxBatchRequest{}
}

func (x *BlockassemblyApiAddTxBatchRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiAddTxBatchRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		polyglot.Encoder(b).Slice(uint32(len(x.TxRequests)), polyglot.AnyKind)
		for _, v := range x.TxRequests {
			v.Encode(b)
		}
	}
}

func (x *BlockassemblyApiAddTxBatchRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiAddTxBatchRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.TxRequests)) != sliceSize {
		x.TxRequests = make([]*BlockassemblyApiAddTxRequest, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		if x.TxRequests[i] == nil {
			x.TxRequests[i] = NewBlockassemblyApiAddTxRequest()
		}
		err = x.TxRequests[i].decode(d)
		if err != nil {
			return err
		}
	}
	return nil
}

type BlockassemblyApiRemoveTxRequest struct {
	error error
	flags uint8

	Txid []byte
}

func NewBlockassemblyApiRemoveTxRequest() *BlockassemblyApiRemoveTxRequest {
	return &BlockassemblyApiRemoveTxRequest{}
}

func (x *BlockassemblyApiRemoveTxRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiRemoveTxRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Txid)
	}
}

func (x *BlockassemblyApiRemoveTxRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiRemoveTxRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Txid, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	return nil
}

type BlockassemblyApiAddTxResponse struct {
	error error
	flags uint8

	Ok bool
}

func NewBlockassemblyApiAddTxResponse() *BlockassemblyApiAddTxResponse {
	return &BlockassemblyApiAddTxResponse{}
}

func (x *BlockassemblyApiAddTxResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiAddTxResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Ok)
	}
}

func (x *BlockassemblyApiAddTxResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiAddTxResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ok, err = d.Bool()
	if err != nil {
		return err
	}
	return nil
}

type BlockassemblyApiAddTxBatchResponse struct {
	error error
	flags uint8

	Ok         bool
	TxIdErrors [][]byte
}

func NewBlockassemblyApiAddTxBatchResponse() *BlockassemblyApiAddTxBatchResponse {
	return &BlockassemblyApiAddTxBatchResponse{}
}

func (x *BlockassemblyApiAddTxBatchResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiAddTxBatchResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Ok)
		polyglot.Encoder(b).Slice(uint32(len(x.TxIdErrors)), polyglot.BytesKind)
		for _, v := range x.TxIdErrors {
			polyglot.Encoder(b).Bytes(v)
		}
	}
}

func (x *BlockassemblyApiAddTxBatchResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiAddTxBatchResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ok, err = d.Bool()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.BytesKind)
	if err != nil {
		return err
	}
	if uint32(len(x.TxIdErrors)) != sliceSize {
		x.TxIdErrors = make([][]byte, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.TxIdErrors[i], err = d.Bytes([]byte{})
		if err != nil {
			return err
		}
	}
	return nil
}

type BlockassemblyApiSubmitMiningSolutionRequest struct {
	error error
	flags uint8

	Id         []byte
	Nonce      uint32
	CoinbaseTx []byte
	Time       uint32
	Version    uint32
}

func NewBlockassemblyApiSubmitMiningSolutionRequest() *BlockassemblyApiSubmitMiningSolutionRequest {
	return &BlockassemblyApiSubmitMiningSolutionRequest{}
}

func (x *BlockassemblyApiSubmitMiningSolutionRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiSubmitMiningSolutionRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Id).Uint32(x.Nonce).Bytes(x.CoinbaseTx).Uint32(x.Time).Uint32(x.Version)
	}
}

func (x *BlockassemblyApiSubmitMiningSolutionRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiSubmitMiningSolutionRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Id, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	x.Nonce, err = d.Uint32()
	if err != nil {
		return err
	}
	x.CoinbaseTx, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	x.Time, err = d.Uint32()
	if err != nil {
		return err
	}
	x.Version, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type BlockassemblyApiSubmitMiningSolutionResponse struct {
	error error
	flags uint8

	Ok bool
}

func NewBlockassemblyApiSubmitMiningSolutionResponse() *BlockassemblyApiSubmitMiningSolutionResponse {
	return &BlockassemblyApiSubmitMiningSolutionResponse{}
}

func (x *BlockassemblyApiSubmitMiningSolutionResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockassemblyApiSubmitMiningSolutionResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Ok)
	}
}

func (x *BlockassemblyApiSubmitMiningSolutionResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockassemblyApiSubmitMiningSolutionResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ok, err = d.Bool()
	if err != nil {
		return err
	}
	return nil
}

type BlockAssemblyAPI interface {
	HealthGRPC(context.Context, *BlockassemblyApiEmptyMessage) (*BlockassemblyApiHealthResponse, error)
	AddTx(context.Context, *BlockassemblyApiAddTxRequest) (*BlockassemblyApiAddTxResponse, error)
	RemoveTx(context.Context, *BlockassemblyApiRemoveTxRequest) (*BlockassemblyApiEmptyMessage, error)
	AddTxBatch(context.Context, *BlockassemblyApiAddTxBatchRequest) (*BlockassemblyApiAddTxBatchResponse, error)
	GetMiningCandidate(context.Context, *BlockassemblyApiEmptyMessage) (*ModelMiningCandidate, error)
	SubmitMiningSolution(context.Context, *BlockassemblyApiSubmitMiningSolutionRequest) (*BlockassemblyApiSubmitMiningSolutionResponse, error)
}

type contextKey int

const connectionContextKey contextKey = 1000

func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

type Server struct {
	*frisbee.Server
	onClosed func(*frisbee.Async, error)
}

func NewServer(blockAssemblyAPI BlockAssemblyAPI, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
	var s *Server
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockassemblyApiEmptyMessage()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockassemblyApiHealthResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockAssemblyAPI.HealthGRPC(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockassemblyApiAddTxRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockassemblyApiAddTxResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockAssemblyAPI.AddTx(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockassemblyApiRemoveTxRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockassemblyApiEmptyMessage
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockAssemblyAPI.RemoveTx(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[13] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockassemblyApiAddTxBatchRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockassemblyApiAddTxBatchResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockAssemblyAPI.AddTxBatch(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[14] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockassemblyApiEmptyMessage()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *ModelMiningCandidate
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockAssemblyAPI.GetMiningCandidate(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[15] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockassemblyApiSubmitMiningSolutionRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockassemblyApiSubmitMiningSolutionResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockAssemblyAPI.SubmitMiningSolution(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	var fsrv *frisbee.Server
	var err error
	if tlsConfig != nil {
		fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	fsrv.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, connectionContextKey, conn)
	}
	s, err = &Server{
		Server: fsrv,
	}, nil

	fsrv.SetOnClosed(func(async *frisbee.Async, err error) {
		if s.onClosed != nil {
			s.onClosed(async, err)
		}
	})
	return s, err
}

func (s *Server) SetOnClosed(f func(*frisbee.Async, error)) error {
	if f == nil {
		return frisbee.OnClosedNil
	}
	s.onClosed = f
	return nil
}

type subBlockAssemblyAPIClient struct {
	client                         *frisbee.Client
	nextHealthGRPC                 uint16
	nextHealthGRPCMu               sync.RWMutex
	inflightHealthGRPC             map[uint16]chan *BlockassemblyApiHealthResponse
	inflightHealthGRPCMu           sync.RWMutex
	nextAddTx                      uint16
	nextAddTxMu                    sync.RWMutex
	inflightAddTx                  map[uint16]chan *BlockassemblyApiAddTxResponse
	inflightAddTxMu                sync.RWMutex
	nextRemoveTx                   uint16
	nextRemoveTxMu                 sync.RWMutex
	inflightRemoveTx               map[uint16]chan *BlockassemblyApiEmptyMessage
	inflightRemoveTxMu             sync.RWMutex
	nextAddTxBatch                 uint16
	nextAddTxBatchMu               sync.RWMutex
	inflightAddTxBatch             map[uint16]chan *BlockassemblyApiAddTxBatchResponse
	inflightAddTxBatchMu           sync.RWMutex
	nextGetMiningCandidate         uint16
	nextGetMiningCandidateMu       sync.RWMutex
	inflightGetMiningCandidate     map[uint16]chan *ModelMiningCandidate
	inflightGetMiningCandidateMu   sync.RWMutex
	nextSubmitMiningSolution       uint16
	nextSubmitMiningSolutionMu     sync.RWMutex
	inflightSubmitMiningSolution   map[uint16]chan *BlockassemblyApiSubmitMiningSolutionResponse
	inflightSubmitMiningSolutionMu sync.RWMutex
	nextStreamingID                uint16
	nextStreamingIDMu              sync.RWMutex
}
type Client struct {
	*frisbee.Client
	BlockAssemblyAPI *subBlockAssemblyAPIClient
}

func NewClient(tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockAssemblyAPI.inflightHealthGRPCMu.RLock()
		if ch, ok := c.BlockAssemblyAPI.inflightHealthGRPC[incoming.Metadata.Id]; ok {
			c.BlockAssemblyAPI.inflightHealthGRPCMu.RUnlock()
			res := NewBlockassemblyApiHealthResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockAssemblyAPI.inflightHealthGRPCMu.RUnlock()
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockAssemblyAPI.inflightAddTxMu.RLock()
		if ch, ok := c.BlockAssemblyAPI.inflightAddTx[incoming.Metadata.Id]; ok {
			c.BlockAssemblyAPI.inflightAddTxMu.RUnlock()
			res := NewBlockassemblyApiAddTxResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockAssemblyAPI.inflightAddTxMu.RUnlock()
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockAssemblyAPI.inflightRemoveTxMu.RLock()
		if ch, ok := c.BlockAssemblyAPI.inflightRemoveTx[incoming.Metadata.Id]; ok {
			c.BlockAssemblyAPI.inflightRemoveTxMu.RUnlock()
			res := NewBlockassemblyApiEmptyMessage()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockAssemblyAPI.inflightRemoveTxMu.RUnlock()
		}
		return
	}
	table[13] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockAssemblyAPI.inflightAddTxBatchMu.RLock()
		if ch, ok := c.BlockAssemblyAPI.inflightAddTxBatch[incoming.Metadata.Id]; ok {
			c.BlockAssemblyAPI.inflightAddTxBatchMu.RUnlock()
			res := NewBlockassemblyApiAddTxBatchResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockAssemblyAPI.inflightAddTxBatchMu.RUnlock()
		}
		return
	}
	table[14] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockAssemblyAPI.inflightGetMiningCandidateMu.RLock()
		if ch, ok := c.BlockAssemblyAPI.inflightGetMiningCandidate[incoming.Metadata.Id]; ok {
			c.BlockAssemblyAPI.inflightGetMiningCandidateMu.RUnlock()
			res := NewModelMiningCandidate()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockAssemblyAPI.inflightGetMiningCandidateMu.RUnlock()
		}
		return
	}
	table[15] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockAssemblyAPI.inflightSubmitMiningSolutionMu.RLock()
		if ch, ok := c.BlockAssemblyAPI.inflightSubmitMiningSolution[incoming.Metadata.Id]; ok {
			c.BlockAssemblyAPI.inflightSubmitMiningSolutionMu.RUnlock()
			res := NewBlockassemblyApiSubmitMiningSolutionResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockAssemblyAPI.inflightSubmitMiningSolutionMu.RUnlock()
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.BlockAssemblyAPI = new(subBlockAssemblyAPIClient)
	c.BlockAssemblyAPI.client = c.Client
	c.BlockAssemblyAPI.nextHealthGRPCMu.Lock()
	c.BlockAssemblyAPI.nextHealthGRPC = 0
	c.BlockAssemblyAPI.nextHealthGRPCMu.Unlock()
	c.BlockAssemblyAPI.inflightHealthGRPC = make(map[uint16]chan *BlockassemblyApiHealthResponse)
	c.BlockAssemblyAPI.nextAddTxMu.Lock()
	c.BlockAssemblyAPI.nextAddTx = 0
	c.BlockAssemblyAPI.nextAddTxMu.Unlock()
	c.BlockAssemblyAPI.inflightAddTx = make(map[uint16]chan *BlockassemblyApiAddTxResponse)
	c.BlockAssemblyAPI.nextRemoveTxMu.Lock()
	c.BlockAssemblyAPI.nextRemoveTx = 0
	c.BlockAssemblyAPI.nextRemoveTxMu.Unlock()
	c.BlockAssemblyAPI.inflightRemoveTx = make(map[uint16]chan *BlockassemblyApiEmptyMessage)
	c.BlockAssemblyAPI.nextAddTxBatchMu.Lock()
	c.BlockAssemblyAPI.nextAddTxBatch = 0
	c.BlockAssemblyAPI.nextAddTxBatchMu.Unlock()
	c.BlockAssemblyAPI.inflightAddTxBatch = make(map[uint16]chan *BlockassemblyApiAddTxBatchResponse)
	c.BlockAssemblyAPI.nextGetMiningCandidateMu.Lock()
	c.BlockAssemblyAPI.nextGetMiningCandidate = 0
	c.BlockAssemblyAPI.nextGetMiningCandidateMu.Unlock()
	c.BlockAssemblyAPI.inflightGetMiningCandidate = make(map[uint16]chan *ModelMiningCandidate)
	c.BlockAssemblyAPI.nextSubmitMiningSolutionMu.Lock()
	c.BlockAssemblyAPI.nextSubmitMiningSolution = 0
	c.BlockAssemblyAPI.nextSubmitMiningSolutionMu.Unlock()
	c.BlockAssemblyAPI.inflightSubmitMiningSolution = make(map[uint16]chan *BlockassemblyApiSubmitMiningSolutionResponse)
	return c, nil
}

func (c *Client) Connect(addr string, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.Connect(addr, func(stream *frisbee.Stream) {})
}

func (c *Client) FromConn(conn net.Conn, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.FromConn(conn, func(stream *frisbee.Stream) {})
}

func (c *subBlockAssemblyAPIClient) HealthGRPC(ctx context.Context, req *BlockassemblyApiEmptyMessage) (res *BlockassemblyApiHealthResponse, err error) {
	ch := make(chan *BlockassemblyApiHealthResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextHealthGRPCMu.Lock()
	c.nextHealthGRPC += 1
	id := c.nextHealthGRPC
	c.nextHealthGRPCMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightHealthGRPCMu.Lock()
	c.inflightHealthGRPC[id] = ch
	c.inflightHealthGRPCMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightHealthGRPCMu.Lock()
	delete(c.inflightHealthGRPC, id)
	c.inflightHealthGRPCMu.Unlock()
	packet.Put(p)
	return
}

func (c *subBlockAssemblyAPIClient) AddTx(ctx context.Context, req *BlockassemblyApiAddTxRequest) (res *BlockassemblyApiAddTxResponse, err error) {
	ch := make(chan *BlockassemblyApiAddTxResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 11

	c.nextAddTxMu.Lock()
	c.nextAddTx += 1
	id := c.nextAddTx
	c.nextAddTxMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightAddTxMu.Lock()
	c.inflightAddTx[id] = ch
	c.inflightAddTxMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightAddTxMu.Lock()
	delete(c.inflightAddTx, id)
	c.inflightAddTxMu.Unlock()
	packet.Put(p)
	return
}

func (c *subBlockAssemblyAPIClient) RemoveTx(ctx context.Context, req *BlockassemblyApiRemoveTxRequest) (res *BlockassemblyApiEmptyMessage, err error) {
	ch := make(chan *BlockassemblyApiEmptyMessage, 1)
	p := packet.Get()
	p.Metadata.Operation = 12

	c.nextRemoveTxMu.Lock()
	c.nextRemoveTx += 1
	id := c.nextRemoveTx
	c.nextRemoveTxMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightRemoveTxMu.Lock()
	c.inflightRemoveTx[id] = ch
	c.inflightRemoveTxMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightRemoveTxMu.Lock()
	delete(c.inflightRemoveTx, id)
	c.inflightRemoveTxMu.Unlock()
	packet.Put(p)
	return
}

func (c *subBlockAssemblyAPIClient) AddTxBatch(ctx context.Context, req *BlockassemblyApiAddTxBatchRequest) (res *BlockassemblyApiAddTxBatchResponse, err error) {
	ch := make(chan *BlockassemblyApiAddTxBatchResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 13

	c.nextAddTxBatchMu.Lock()
	c.nextAddTxBatch += 1
	id := c.nextAddTxBatch
	c.nextAddTxBatchMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightAddTxBatchMu.Lock()
	c.inflightAddTxBatch[id] = ch
	c.inflightAddTxBatchMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightAddTxBatchMu.Lock()
	delete(c.inflightAddTxBatch, id)
	c.inflightAddTxBatchMu.Unlock()
	packet.Put(p)
	return
}

func (c *subBlockAssemblyAPIClient) GetMiningCandidate(ctx context.Context, req *BlockassemblyApiEmptyMessage) (res *ModelMiningCandidate, err error) {
	ch := make(chan *ModelMiningCandidate, 1)
	p := packet.Get()
	p.Metadata.Operation = 14

	c.nextGetMiningCandidateMu.Lock()
	c.nextGetMiningCandidate += 1
	id := c.nextGetMiningCandidate
	c.nextGetMiningCandidateMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightGetMiningCandidateMu.Lock()
	c.inflightGetMiningCandidate[id] = ch
	c.inflightGetMiningCandidateMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightGetMiningCandidateMu.Lock()
	delete(c.inflightGetMiningCandidate, id)
	c.inflightGetMiningCandidateMu.Unlock()
	packet.Put(p)
	return
}

func (c *subBlockAssemblyAPIClient) SubmitMiningSolution(ctx context.Context, req *BlockassemblyApiSubmitMiningSolutionRequest) (res *BlockassemblyApiSubmitMiningSolutionResponse, err error) {
	ch := make(chan *BlockassemblyApiSubmitMiningSolutionResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 15

	c.nextSubmitMiningSolutionMu.Lock()
	c.nextSubmitMiningSolution += 1
	id := c.nextSubmitMiningSolution
	c.nextSubmitMiningSolutionMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightSubmitMiningSolutionMu.Lock()
	c.inflightSubmitMiningSolution[id] = ch
	c.inflightSubmitMiningSolutionMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightSubmitMiningSolutionMu.Lock()
	delete(c.inflightSubmitMiningSolution, id)
	c.inflightSubmitMiningSolutionMu.Unlock()
	packet.Put(p)
	return
}

type CloseError struct {
	err error
}

func NewCloseError(err error) CloseError {
	return CloseError{err: err}
}

func (e CloseError) Error() string {
	return e.err.Error()
}
