// Code generated by fRPC Go v0.7.3, DO NOT EDIT.
// source: services/propagation/propagation_api/propagation_api.proto

package propagation_api

import (
	"errors"
	"github.com/loopholelabs/polyglot"
	"net"

	"context"
	"crypto/tls"
	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/rs/zerolog"

	"sync"

	"go.uber.org/atomic"
	"io"
)

var (
	ErrNilDecode = errors.New("cannot decode into a nil root struct")
)

type PropagationApiEmptyMessage struct {
	error error
	flags uint8
}

func NewPropagationApiEmptyMessage() *PropagationApiEmptyMessage {
	return &PropagationApiEmptyMessage{}
}

func (x *PropagationApiEmptyMessage) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *PropagationApiEmptyMessage) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *PropagationApiEmptyMessage) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *PropagationApiEmptyMessage) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type PropagationApiHealthResponse struct {
	error error
	flags uint8

	Ok        bool
	Details   string
	Timestamp uint32
}

func NewPropagationApiHealthResponse() *PropagationApiHealthResponse {
	return &PropagationApiHealthResponse{}
}

func (x *PropagationApiHealthResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *PropagationApiHealthResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Ok).String(x.Details).Uint32(x.Timestamp)
	}
}

func (x *PropagationApiHealthResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *PropagationApiHealthResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ok, err = d.Bool()
	if err != nil {
		return err
	}
	x.Details, err = d.String()
	if err != nil {
		return err
	}
	x.Timestamp, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type PropagationApiGetRequest struct {
	error error
	flags uint8

	Txid []byte
}

func NewPropagationApiGetRequest() *PropagationApiGetRequest {
	return &PropagationApiGetRequest{}
}

func (x *PropagationApiGetRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *PropagationApiGetRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Txid)
	}
}

func (x *PropagationApiGetRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *PropagationApiGetRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Txid, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	return nil
}

type PropagationApiGetResponse struct {
	error error
	flags uint8

	Tx []byte
}

func NewPropagationApiGetResponse() *PropagationApiGetResponse {
	return &PropagationApiGetResponse{}
}

func (x *PropagationApiGetResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *PropagationApiGetResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Tx)
	}
}

func (x *PropagationApiGetResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *PropagationApiGetResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Tx, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	return nil
}

type PropagationApiProcessTransactionRequest struct {
	error error
	flags uint8

	Tx []byte
}

func NewPropagationApiProcessTransactionRequest() *PropagationApiProcessTransactionRequest {
	return &PropagationApiProcessTransactionRequest{}
}

func (x *PropagationApiProcessTransactionRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *PropagationApiProcessTransactionRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Tx)
	}
}

func (x *PropagationApiProcessTransactionRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *PropagationApiProcessTransactionRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Tx, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	return nil
}

type PropagationApiProcessTransactionHexRequest struct {
	error error
	flags uint8

	Tx string
}

func NewPropagationApiProcessTransactionHexRequest() *PropagationApiProcessTransactionHexRequest {
	return &PropagationApiProcessTransactionHexRequest{}
}

func (x *PropagationApiProcessTransactionHexRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *PropagationApiProcessTransactionHexRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Tx)
	}
}

func (x *PropagationApiProcessTransactionHexRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *PropagationApiProcessTransactionHexRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Tx, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type PropagationAPI interface {
	HealthGRPC(context.Context, *PropagationApiEmptyMessage) (*PropagationApiHealthResponse, error)
	ProcessTransaction(context.Context, *PropagationApiProcessTransactionRequest) (*PropagationApiEmptyMessage, error)
	ProcessTransactionHex(context.Context, *PropagationApiProcessTransactionHexRequest) (*PropagationApiEmptyMessage, error)

	ProcessTransactionStream(srv *ProcessTransactionStreamServer) error
	ProcessTransactionDebug(context.Context, *PropagationApiProcessTransactionRequest) (*PropagationApiEmptyMessage, error)
}

type contextKey int

const connectionContextKey contextKey = 1000

func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

type RPCStreamOpen struct {
	operation uint16
}

func (x *RPCStreamOpen) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *RPCStreamOpen) Encode(b *polyglot.Buffer) {
	polyglot.Encoder(b).Uint16(x.operation)
}

func (x *RPCStreamOpen) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *RPCStreamOpen) decode(d *polyglot.Decoder) error {
	var err error
	x.operation, err = d.Uint16()
	return err
}

type Server struct {
	*frisbee.Server
	onClosed func(*frisbee.Async, error)
}

func NewServer(propagationAPI PropagationAPI, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
	var s *Server
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewPropagationApiEmptyMessage()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *PropagationApiHealthResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = propagationAPI.HealthGRPC(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewPropagationApiProcessTransactionRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *PropagationApiEmptyMessage
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = propagationAPI.ProcessTransaction(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewPropagationApiProcessTransactionHexRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *PropagationApiEmptyMessage
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = propagationAPI.ProcessTransactionHex(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[14] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewPropagationApiProcessTransactionRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *PropagationApiEmptyMessage
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = propagationAPI.ProcessTransactionDebug(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	var fsrv *frisbee.Server
	var err error
	if tlsConfig != nil {
		fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	fsrv.SetStreamHandler(func(conn *frisbee.Async, stream *frisbee.Stream) {
		p, err := stream.ReadPacket()
		if err != nil {
			return
		}
		open := &RPCStreamOpen{}
		err = open.Decode(*p.Content)
		if err != nil {
			stream.Close()
			return
		}
		switch open.operation {
		case 13:
			s.createProcessTransactionStreamServer(propagationAPI, stream)
		}
	})

	fsrv.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, connectionContextKey, conn)
	}
	s, err = &Server{
		Server: fsrv,
	}, nil

	fsrv.SetOnClosed(func(async *frisbee.Async, err error) {
		if s.onClosed != nil {
			s.onClosed(async, err)
		}
	})
	return s, err
}

func (s *Server) SetOnClosed(f func(*frisbee.Async, error)) error {
	if f == nil {
		return frisbee.OnClosedNil
	}
	s.onClosed = f
	return nil
}

type ProcessTransactionStreamServer struct {
	recv func() (*PropagationApiProcessTransactionRequest, error)
	send func(*PropagationApiEmptyMessage) error

	stream *frisbee.Stream
	closed *atomic.Bool
}

func (s *Server) createProcessTransactionStreamServer(propagationAPI PropagationAPI, stream *frisbee.Stream) {
	srv := &ProcessTransactionStreamServer{
		closed: atomic.NewBool(false),
		stream: stream,
	}

	srv.recv = func() (*PropagationApiProcessTransactionRequest, error) {
		p, err := srv.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewPropagationApiProcessTransactionRequest()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}
	srv.send = func(m *PropagationApiEmptyMessage) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return srv.stream.WritePacket(p)
	}

	go func() {
		err := propagationAPI.ProcessTransactionStream(srv)
		if err != nil {
			res := PropagationApiEmptyMessage{error: err}
			res.flags = SetErrorFlag(res.flags, true)
			srv.CloseAndSend(&res)
		} else {
			srv.CloseSend()
		}
	}()
}

func (x *ProcessTransactionStreamServer) Recv() (*PropagationApiProcessTransactionRequest, error) {
	return x.recv()
}

func (x *ProcessTransactionStreamServer) close() {
	x.stream.Close()
}
func (x *ProcessTransactionStreamServer) Send(m *PropagationApiEmptyMessage) error {
	return x.send(m)
}
func (x *ProcessTransactionStreamServer) CloseSend() error {
	return x.send(&PropagationApiEmptyMessage{error: io.EOF})
}

func (x *ProcessTransactionStreamServer) CloseAndSend(m *PropagationApiEmptyMessage) error {
	err := x.send(m)
	if err != nil {
		return err
	}
	return x.CloseSend()
}

type subPropagationAPIClient struct {
	client                            *frisbee.Client
	nextHealthGRPC                    uint16
	nextHealthGRPCMu                  sync.RWMutex
	inflightHealthGRPC                map[uint16]chan *PropagationApiHealthResponse
	inflightHealthGRPCMu              sync.RWMutex
	nextProcessTransaction            uint16
	nextProcessTransactionMu          sync.RWMutex
	inflightProcessTransaction        map[uint16]chan *PropagationApiEmptyMessage
	inflightProcessTransactionMu      sync.RWMutex
	nextProcessTransactionHex         uint16
	nextProcessTransactionHexMu       sync.RWMutex
	inflightProcessTransactionHex     map[uint16]chan *PropagationApiEmptyMessage
	inflightProcessTransactionHexMu   sync.RWMutex
	nextProcessTransactionDebug       uint16
	nextProcessTransactionDebugMu     sync.RWMutex
	inflightProcessTransactionDebug   map[uint16]chan *PropagationApiEmptyMessage
	inflightProcessTransactionDebugMu sync.RWMutex
	nextStreamingID                   uint16
	nextStreamingIDMu                 sync.RWMutex
}
type Client struct {
	*frisbee.Client
	PropagationAPI *subPropagationAPIClient
}

func NewClient(tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.PropagationAPI.inflightHealthGRPCMu.RLock()
		if ch, ok := c.PropagationAPI.inflightHealthGRPC[incoming.Metadata.Id]; ok {
			c.PropagationAPI.inflightHealthGRPCMu.RUnlock()
			res := NewPropagationApiHealthResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.PropagationAPI.inflightHealthGRPCMu.RUnlock()
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.PropagationAPI.inflightProcessTransactionMu.RLock()
		if ch, ok := c.PropagationAPI.inflightProcessTransaction[incoming.Metadata.Id]; ok {
			c.PropagationAPI.inflightProcessTransactionMu.RUnlock()
			res := NewPropagationApiEmptyMessage()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.PropagationAPI.inflightProcessTransactionMu.RUnlock()
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.PropagationAPI.inflightProcessTransactionHexMu.RLock()
		if ch, ok := c.PropagationAPI.inflightProcessTransactionHex[incoming.Metadata.Id]; ok {
			c.PropagationAPI.inflightProcessTransactionHexMu.RUnlock()
			res := NewPropagationApiEmptyMessage()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.PropagationAPI.inflightProcessTransactionHexMu.RUnlock()
		}
		return
	}
	table[14] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.PropagationAPI.inflightProcessTransactionDebugMu.RLock()
		if ch, ok := c.PropagationAPI.inflightProcessTransactionDebug[incoming.Metadata.Id]; ok {
			c.PropagationAPI.inflightProcessTransactionDebugMu.RUnlock()
			res := NewPropagationApiEmptyMessage()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.PropagationAPI.inflightProcessTransactionDebugMu.RUnlock()
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.PropagationAPI = new(subPropagationAPIClient)
	c.PropagationAPI.client = c.Client
	c.PropagationAPI.nextHealthGRPCMu.Lock()
	c.PropagationAPI.nextHealthGRPC = 0
	c.PropagationAPI.nextHealthGRPCMu.Unlock()
	c.PropagationAPI.inflightHealthGRPC = make(map[uint16]chan *PropagationApiHealthResponse)
	c.PropagationAPI.nextProcessTransactionMu.Lock()
	c.PropagationAPI.nextProcessTransaction = 0
	c.PropagationAPI.nextProcessTransactionMu.Unlock()
	c.PropagationAPI.inflightProcessTransaction = make(map[uint16]chan *PropagationApiEmptyMessage)
	c.PropagationAPI.nextProcessTransactionHexMu.Lock()
	c.PropagationAPI.nextProcessTransactionHex = 0
	c.PropagationAPI.nextProcessTransactionHexMu.Unlock()
	c.PropagationAPI.inflightProcessTransactionHex = make(map[uint16]chan *PropagationApiEmptyMessage)
	c.PropagationAPI.nextProcessTransactionDebugMu.Lock()
	c.PropagationAPI.nextProcessTransactionDebug = 0
	c.PropagationAPI.nextProcessTransactionDebugMu.Unlock()
	c.PropagationAPI.inflightProcessTransactionDebug = make(map[uint16]chan *PropagationApiEmptyMessage)
	return c, nil
}

func (c *Client) Connect(addr string, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.Connect(addr, func(stream *frisbee.Stream) {})
}

func (c *Client) FromConn(conn net.Conn, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.FromConn(conn, func(stream *frisbee.Stream) {})
}

func (c *subPropagationAPIClient) HealthGRPC(ctx context.Context, req *PropagationApiEmptyMessage) (res *PropagationApiHealthResponse, err error) {
	ch := make(chan *PropagationApiHealthResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextHealthGRPCMu.Lock()
	c.nextHealthGRPC += 1
	id := c.nextHealthGRPC
	c.nextHealthGRPCMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightHealthGRPCMu.Lock()
	c.inflightHealthGRPC[id] = ch
	c.inflightHealthGRPCMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightHealthGRPCMu.Lock()
	delete(c.inflightHealthGRPC, id)
	c.inflightHealthGRPCMu.Unlock()
	packet.Put(p)
	return
}

func (c *subPropagationAPIClient) ProcessTransaction(ctx context.Context, req *PropagationApiProcessTransactionRequest) (res *PropagationApiEmptyMessage, err error) {
	ch := make(chan *PropagationApiEmptyMessage, 1)
	p := packet.Get()
	p.Metadata.Operation = 11

	c.nextProcessTransactionMu.Lock()
	c.nextProcessTransaction += 1
	id := c.nextProcessTransaction
	c.nextProcessTransactionMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightProcessTransactionMu.Lock()
	c.inflightProcessTransaction[id] = ch
	c.inflightProcessTransactionMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightProcessTransactionMu.Lock()
	delete(c.inflightProcessTransaction, id)
	c.inflightProcessTransactionMu.Unlock()
	packet.Put(p)
	return
}

func (c *subPropagationAPIClient) ProcessTransactionHex(ctx context.Context, req *PropagationApiProcessTransactionHexRequest) (res *PropagationApiEmptyMessage, err error) {
	ch := make(chan *PropagationApiEmptyMessage, 1)
	p := packet.Get()
	p.Metadata.Operation = 12

	c.nextProcessTransactionHexMu.Lock()
	c.nextProcessTransactionHex += 1
	id := c.nextProcessTransactionHex
	c.nextProcessTransactionHexMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightProcessTransactionHexMu.Lock()
	c.inflightProcessTransactionHex[id] = ch
	c.inflightProcessTransactionHexMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightProcessTransactionHexMu.Lock()
	delete(c.inflightProcessTransactionHex, id)
	c.inflightProcessTransactionHexMu.Unlock()
	packet.Put(p)
	return
}

func (c *subPropagationAPIClient) ProcessTransactionStream(ctx context.Context, req *PropagationApiProcessTransactionRequest) (*ProcessTransactionStreamClient, error) {
	p := packet.Get()

	c.nextStreamingIDMu.Lock()
	c.nextStreamingID += 1
	id := c.nextStreamingID
	c.nextStreamingIDMu.Unlock()

	open := &RPCStreamOpen{operation: 13}

	open.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))

	fStream := c.client.Stream(id)
	fStream.WritePacket(p)

	if req != nil {
		p2 := packet.Get()
		req.Encode(p2.Content)
		p2.Metadata.ContentLength = uint32(len(*p2.Content))
		fStream.WritePacket(p2)
	}

	stream := ProcessTransactionStreamClient{
		context: ctx,
		stream:  fStream,
		closed:  atomic.NewBool(false),
	}

	stream.recv = func() (*PropagationApiEmptyMessage, error) {
		p, err := stream.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewPropagationApiEmptyMessage()
		err = res.Decode(*p.Content)
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}

	stream.close = func() {
		stream.stream.Close()
	}
	stream.send = func(m *PropagationApiProcessTransactionRequest) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32(len(*p.Content))
		return stream.stream.WritePacket(p)
	}
	return &stream, nil
}

type ProcessTransactionStreamClient struct {
	context context.Context
	recv    func() (*PropagationApiEmptyMessage, error)
	close   func()
	closed  *atomic.Bool

	stream *frisbee.Stream
	send   func(*PropagationApiProcessTransactionRequest) error
}

func (x *ProcessTransactionStreamClient) Recv() (*PropagationApiEmptyMessage, error) {
	return x.recv()
}
func (x *ProcessTransactionStreamClient) Send(m *PropagationApiProcessTransactionRequest) error {
	return x.send(m)
}

func (x *ProcessTransactionStreamClient) CloseSend() error {
	return x.send(&PropagationApiProcessTransactionRequest{error: io.EOF})
}

func (x *ProcessTransactionStreamClient) CloseAndRecv() (*PropagationApiEmptyMessage, error) {
	err := x.send(&PropagationApiProcessTransactionRequest{error: io.EOF})
	if err != nil {
		return nil, err
	}
	return x.recv()
}

func (c *subPropagationAPIClient) ProcessTransactionDebug(ctx context.Context, req *PropagationApiProcessTransactionRequest) (res *PropagationApiEmptyMessage, err error) {
	ch := make(chan *PropagationApiEmptyMessage, 1)
	p := packet.Get()
	p.Metadata.Operation = 14

	c.nextProcessTransactionDebugMu.Lock()
	c.nextProcessTransactionDebug += 1
	id := c.nextProcessTransactionDebug
	c.nextProcessTransactionDebugMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightProcessTransactionDebugMu.Lock()
	c.inflightProcessTransactionDebug[id] = ch
	c.inflightProcessTransactionDebugMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightProcessTransactionDebugMu.Lock()
	delete(c.inflightProcessTransactionDebug, id)
	c.inflightProcessTransactionDebugMu.Unlock()
	packet.Put(p)
	return
}

type CloseError struct {
	err error
}

func NewCloseError(err error) CloseError {
	return CloseError{err: err}
}

func (e CloseError) Error() string {
	return e.err.Error()
}
