// Code generated by fRPC Go v0.7.3, DO NOT EDIT.
// source: services/blockvalidation/blockvalidation_api/blockvalidation_api.proto

package blockvalidation_api

import (
	"errors"
	"net"

	"github.com/loopholelabs/polyglot"

	"context"
	"crypto/tls"

	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/rs/zerolog"

	"sync"
)

var (
	ErrNilDecode = errors.New("cannot decode into a nil root struct")
)

type BlockvalidationApiEmptyMessage struct {
	error error
	flags uint8
}

func NewBlockvalidationApiEmptyMessage() *BlockvalidationApiEmptyMessage {
	return &BlockvalidationApiEmptyMessage{}
}

func (x *BlockvalidationApiEmptyMessage) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockvalidationApiEmptyMessage) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *BlockvalidationApiEmptyMessage) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockvalidationApiEmptyMessage) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type BlockvalidationApiHealthResponse struct {
	error error
	flags uint8

	Ok        bool
	Details   string
	Timestamp uint32
}

func NewBlockvalidationApiHealthResponse() *BlockvalidationApiHealthResponse {
	return &BlockvalidationApiHealthResponse{}
}

func (x *BlockvalidationApiHealthResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockvalidationApiHealthResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Ok).String(x.Details).Uint32(x.Timestamp)
	}
}

func (x *BlockvalidationApiHealthResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockvalidationApiHealthResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ok, err = d.Bool()
	if err != nil {
		return err
	}
	x.Details, err = d.String()
	if err != nil {
		return err
	}
	x.Timestamp, err = d.Uint32()
	if err != nil {
		return err
	}
	return nil
}

type BlockvalidationApiBlockFoundRequest struct {
	error error
	flags uint8

	Hash    []byte
	BaseUrl string
}

func NewBlockvalidationApiBlockFoundRequest() *BlockvalidationApiBlockFoundRequest {
	return &BlockvalidationApiBlockFoundRequest{}
}

func (x *BlockvalidationApiBlockFoundRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockvalidationApiBlockFoundRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Hash).String(x.BaseUrl)
	}
}

func (x *BlockvalidationApiBlockFoundRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockvalidationApiBlockFoundRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Hash, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	x.BaseUrl, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type BlockvalidationApiSubtreeFoundRequest struct {
	error error
	flags uint8

	Hash    []byte
	BaseUrl string
}

func NewBlockvalidationApiSubtreeFoundRequest() *BlockvalidationApiSubtreeFoundRequest {
	return &BlockvalidationApiSubtreeFoundRequest{}
}

func (x *BlockvalidationApiSubtreeFoundRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockvalidationApiSubtreeFoundRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Hash).String(x.BaseUrl)
	}
}

func (x *BlockvalidationApiSubtreeFoundRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockvalidationApiSubtreeFoundRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Hash, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	x.BaseUrl, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type BlockvalidationApiGetSubtreeRequest struct {
	error error
	flags uint8

	Hash []byte
}

func NewBlockvalidationApiGetSubtreeRequest() *BlockvalidationApiGetSubtreeRequest {
	return &BlockvalidationApiGetSubtreeRequest{}
}

func (x *BlockvalidationApiGetSubtreeRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockvalidationApiGetSubtreeRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Hash)
	}
}

func (x *BlockvalidationApiGetSubtreeRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockvalidationApiGetSubtreeRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Hash, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	return nil
}

type BlockvalidationApiGetSubtreeResponse struct {
	error error
	flags uint8

	Subtree []byte
}

func NewBlockvalidationApiGetSubtreeResponse() *BlockvalidationApiGetSubtreeResponse {
	return &BlockvalidationApiGetSubtreeResponse{}
}

func (x *BlockvalidationApiGetSubtreeResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockvalidationApiGetSubtreeResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bytes(x.Subtree)
	}
}

func (x *BlockvalidationApiGetSubtreeResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockvalidationApiGetSubtreeResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Subtree, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	return nil
}

type BlockvalidationApiSetTxMetaRequest struct {
	error error
	flags uint8

	Data [][]byte
}

func NewBlockvalidationApiSetTxMetaRequest() *BlockvalidationApiSetTxMetaRequest {
	return &BlockvalidationApiSetTxMetaRequest{}
}

func (x *BlockvalidationApiSetTxMetaRequest) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockvalidationApiSetTxMetaRequest) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		polyglot.Encoder(b).Slice(uint32(len(x.Data)), polyglot.BytesKind)
		for _, v := range x.Data {
			polyglot.Encoder(b).Bytes(v)
		}
	}
}

func (x *BlockvalidationApiSetTxMetaRequest) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockvalidationApiSetTxMetaRequest) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.BytesKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Data)) != sliceSize {
		x.Data = make([][]byte, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.Data[i], err = d.Bytes([]byte{})
		if err != nil {
			return err
		}
	}
	return nil
}

type BlockvalidationApiSetTxMetaResponse struct {
	error error
	flags uint8

	Ok bool
}

func NewBlockvalidationApiSetTxMetaResponse() *BlockvalidationApiSetTxMetaResponse {
	return &BlockvalidationApiSetTxMetaResponse{}
}

func (x *BlockvalidationApiSetTxMetaResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *BlockvalidationApiSetTxMetaResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).Bool(x.Ok)
	}
}

func (x *BlockvalidationApiSetTxMetaResponse) Decode(b []byte) error {
	if x == nil {
		return ErrNilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *BlockvalidationApiSetTxMetaResponse) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Ok, err = d.Bool()
	if err != nil {
		return err
	}
	return nil
}

type BlockValidationAPI interface {
	Health(context.Context, *BlockvalidationApiEmptyMessage) (*BlockvalidationApiHealthResponse, error)
	BlockFound(context.Context, *BlockvalidationApiBlockFoundRequest) (*BlockvalidationApiEmptyMessage, error)
	SubtreeFound(context.Context, *BlockvalidationApiSubtreeFoundRequest) (*BlockvalidationApiEmptyMessage, error)
	Get(context.Context, *BlockvalidationApiGetSubtreeRequest) (*BlockvalidationApiGetSubtreeResponse, error)
	SetTxMeta(context.Context, *BlockvalidationApiSetTxMetaRequest) (*BlockvalidationApiSetTxMetaResponse, error)
}

type contextKey int

const connectionContextKey contextKey = 1000

func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

type Server struct {
	*frisbee.Server
	onClosed func(*frisbee.Async, error)
}

func NewServer(blockValidationAPI BlockValidationAPI, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
	var s *Server
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockvalidationApiEmptyMessage()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockvalidationApiHealthResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockValidationAPI.Health(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockvalidationApiBlockFoundRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockvalidationApiEmptyMessage
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockValidationAPI.BlockFound(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockvalidationApiSubtreeFoundRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockvalidationApiEmptyMessage
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockValidationAPI.SubtreeFound(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[13] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockvalidationApiGetSubtreeRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockvalidationApiGetSubtreeResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockValidationAPI.Get(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	table[14] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		req := NewBlockvalidationApiSetTxMetaRequest()
		err := req.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
		if err == nil {
			var res *BlockvalidationApiSetTxMetaResponse
			outgoing = incoming
			outgoing.Content.Reset()
			res, err = blockValidationAPI.SetTxMeta(ctx, req)
			if err != nil {
				if _, ok := err.(CloseError); ok {
					action = frisbee.CLOSE
				}
				res.Error(outgoing.Content, err)
			} else {
				res.Encode(outgoing.Content)
			}
			outgoing.Metadata.ContentLength = uint32(len(*outgoing.Content))
		}
		return
	}
	var fsrv *frisbee.Server
	var err error
	if tlsConfig != nil {
		fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	fsrv.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, connectionContextKey, conn)
	}
	s, err = &Server{
		Server: fsrv,
	}, nil

	fsrv.SetOnClosed(func(async *frisbee.Async, err error) {
		if s.onClosed != nil {
			s.onClosed(async, err)
		}
	})
	return s, err
}

func (s *Server) SetOnClosed(f func(*frisbee.Async, error)) error {
	if f == nil {
		return frisbee.OnClosedNil
	}
	s.onClosed = f
	return nil
}

type subBlockValidationAPIClient struct {
	client                 *frisbee.Client
	nextHealth             uint16
	nextHealthMu           sync.RWMutex
	inflightHealth         map[uint16]chan *BlockvalidationApiHealthResponse
	inflightHealthMu       sync.RWMutex
	nextBlockFound         uint16
	nextBlockFoundMu       sync.RWMutex
	inflightBlockFound     map[uint16]chan *BlockvalidationApiEmptyMessage
	inflightBlockFoundMu   sync.RWMutex
	nextSubtreeFound       uint16
	nextSubtreeFoundMu     sync.RWMutex
	inflightSubtreeFound   map[uint16]chan *BlockvalidationApiEmptyMessage
	inflightSubtreeFoundMu sync.RWMutex
	nextGet                uint16
	nextGetMu              sync.RWMutex
	inflightGet            map[uint16]chan *BlockvalidationApiGetSubtreeResponse
	inflightGetMu          sync.RWMutex
	nextSetTxMeta          uint16
	nextSetTxMetaMu        sync.RWMutex
	inflightSetTxMeta      map[uint16]chan *BlockvalidationApiSetTxMetaResponse
	inflightSetTxMetaMu    sync.RWMutex
	nextStreamingID        uint16
	nextStreamingIDMu      sync.RWMutex
}
type Client struct {
	*frisbee.Client
	BlockValidationAPI *subBlockValidationAPIClient
}

func NewClient(tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	table[10] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockValidationAPI.inflightHealthMu.RLock()
		if ch, ok := c.BlockValidationAPI.inflightHealth[incoming.Metadata.Id]; ok {
			c.BlockValidationAPI.inflightHealthMu.RUnlock()
			res := NewBlockvalidationApiHealthResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockValidationAPI.inflightHealthMu.RUnlock()
		}
		return
	}
	table[11] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockValidationAPI.inflightBlockFoundMu.RLock()
		if ch, ok := c.BlockValidationAPI.inflightBlockFound[incoming.Metadata.Id]; ok {
			c.BlockValidationAPI.inflightBlockFoundMu.RUnlock()
			res := NewBlockvalidationApiEmptyMessage()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockValidationAPI.inflightBlockFoundMu.RUnlock()
		}
		return
	}
	table[12] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockValidationAPI.inflightSubtreeFoundMu.RLock()
		if ch, ok := c.BlockValidationAPI.inflightSubtreeFound[incoming.Metadata.Id]; ok {
			c.BlockValidationAPI.inflightSubtreeFoundMu.RUnlock()
			res := NewBlockvalidationApiEmptyMessage()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockValidationAPI.inflightSubtreeFoundMu.RUnlock()
		}
		return
	}
	table[13] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockValidationAPI.inflightGetMu.RLock()
		if ch, ok := c.BlockValidationAPI.inflightGet[incoming.Metadata.Id]; ok {
			c.BlockValidationAPI.inflightGetMu.RUnlock()
			res := NewBlockvalidationApiGetSubtreeResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockValidationAPI.inflightGetMu.RUnlock()
		}
		return
	}
	table[14] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
		c.BlockValidationAPI.inflightSetTxMetaMu.RLock()
		if ch, ok := c.BlockValidationAPI.inflightSetTxMeta[incoming.Metadata.Id]; ok {
			c.BlockValidationAPI.inflightSetTxMetaMu.RUnlock()
			res := NewBlockvalidationApiSetTxMetaResponse()
			res.Decode((*incoming.Content)[:incoming.Metadata.ContentLength])
			ch <- res
		} else {
			c.BlockValidationAPI.inflightSetTxMetaMu.RUnlock()
		}
		return
	}
	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.BlockValidationAPI = new(subBlockValidationAPIClient)
	c.BlockValidationAPI.client = c.Client
	c.BlockValidationAPI.nextHealthMu.Lock()
	c.BlockValidationAPI.nextHealth = 0
	c.BlockValidationAPI.nextHealthMu.Unlock()
	c.BlockValidationAPI.inflightHealth = make(map[uint16]chan *BlockvalidationApiHealthResponse)
	c.BlockValidationAPI.nextBlockFoundMu.Lock()
	c.BlockValidationAPI.nextBlockFound = 0
	c.BlockValidationAPI.nextBlockFoundMu.Unlock()
	c.BlockValidationAPI.inflightBlockFound = make(map[uint16]chan *BlockvalidationApiEmptyMessage)
	c.BlockValidationAPI.nextSubtreeFoundMu.Lock()
	c.BlockValidationAPI.nextSubtreeFound = 0
	c.BlockValidationAPI.nextSubtreeFoundMu.Unlock()
	c.BlockValidationAPI.inflightSubtreeFound = make(map[uint16]chan *BlockvalidationApiEmptyMessage)
	c.BlockValidationAPI.nextGetMu.Lock()
	c.BlockValidationAPI.nextGet = 0
	c.BlockValidationAPI.nextGetMu.Unlock()
	c.BlockValidationAPI.inflightGet = make(map[uint16]chan *BlockvalidationApiGetSubtreeResponse)
	c.BlockValidationAPI.nextSetTxMetaMu.Lock()
	c.BlockValidationAPI.nextSetTxMeta = 0
	c.BlockValidationAPI.nextSetTxMetaMu.Unlock()
	c.BlockValidationAPI.inflightSetTxMeta = make(map[uint16]chan *BlockvalidationApiSetTxMetaResponse)
	return c, nil
}

func (c *Client) Connect(addr string, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.Connect(addr, func(stream *frisbee.Stream) {})
}

func (c *Client) FromConn(conn net.Conn, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.FromConn(conn, func(stream *frisbee.Stream) {})
}

func (c *subBlockValidationAPIClient) Health(ctx context.Context, req *BlockvalidationApiEmptyMessage) (res *BlockvalidationApiHealthResponse, err error) {
	ch := make(chan *BlockvalidationApiHealthResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 10

	c.nextHealthMu.Lock()
	c.nextHealth += 1
	id := c.nextHealth
	c.nextHealthMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightHealthMu.Lock()
	c.inflightHealth[id] = ch
	c.inflightHealthMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightHealthMu.Lock()
	delete(c.inflightHealth, id)
	c.inflightHealthMu.Unlock()
	packet.Put(p)
	return
}

func (c *subBlockValidationAPIClient) BlockFound(ctx context.Context, req *BlockvalidationApiBlockFoundRequest) (res *BlockvalidationApiEmptyMessage, err error) {
	ch := make(chan *BlockvalidationApiEmptyMessage, 1)
	p := packet.Get()
	p.Metadata.Operation = 11

	c.nextBlockFoundMu.Lock()
	c.nextBlockFound += 1
	id := c.nextBlockFound
	c.nextBlockFoundMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightBlockFoundMu.Lock()
	c.inflightBlockFound[id] = ch
	c.inflightBlockFoundMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightBlockFoundMu.Lock()
	delete(c.inflightBlockFound, id)
	c.inflightBlockFoundMu.Unlock()
	packet.Put(p)
	return
}

func (c *subBlockValidationAPIClient) SubtreeFound(ctx context.Context, req *BlockvalidationApiSubtreeFoundRequest) (res *BlockvalidationApiEmptyMessage, err error) {
	ch := make(chan *BlockvalidationApiEmptyMessage, 1)
	p := packet.Get()
	p.Metadata.Operation = 12

	c.nextSubtreeFoundMu.Lock()
	c.nextSubtreeFound += 1
	id := c.nextSubtreeFound
	c.nextSubtreeFoundMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightSubtreeFoundMu.Lock()
	c.inflightSubtreeFound[id] = ch
	c.inflightSubtreeFoundMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightSubtreeFoundMu.Lock()
	delete(c.inflightSubtreeFound, id)
	c.inflightSubtreeFoundMu.Unlock()
	packet.Put(p)
	return
}

func (c *subBlockValidationAPIClient) Get(ctx context.Context, req *BlockvalidationApiGetSubtreeRequest) (res *BlockvalidationApiGetSubtreeResponse, err error) {
	ch := make(chan *BlockvalidationApiGetSubtreeResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 13

	c.nextGetMu.Lock()
	c.nextGet += 1
	id := c.nextGet
	c.nextGetMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightGetMu.Lock()
	c.inflightGet[id] = ch
	c.inflightGetMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightGetMu.Lock()
	delete(c.inflightGet, id)
	c.inflightGetMu.Unlock()
	packet.Put(p)
	return
}

func (c *subBlockValidationAPIClient) SetTxMeta(ctx context.Context, req *BlockvalidationApiSetTxMetaRequest) (res *BlockvalidationApiSetTxMetaResponse, err error) {
	ch := make(chan *BlockvalidationApiSetTxMetaResponse, 1)
	p := packet.Get()
	p.Metadata.Operation = 14

	c.nextSetTxMetaMu.Lock()
	c.nextSetTxMeta += 1
	id := c.nextSetTxMeta
	c.nextSetTxMetaMu.Unlock()
	p.Metadata.Id = id

	req.Encode(p.Content)
	p.Metadata.ContentLength = uint32(len(*p.Content))
	c.inflightSetTxMetaMu.Lock()
	c.inflightSetTxMeta[id] = ch
	c.inflightSetTxMetaMu.Unlock()
	err = c.client.WritePacket(p)
	if err != nil {
		packet.Put(p)
		return
	}
	select {
	case res = <-ch:
		err = res.error
	case <-ctx.Done():
		err = ctx.Err()
	}
	c.inflightSetTxMetaMu.Lock()
	delete(c.inflightSetTxMeta, id)
	c.inflightSetTxMetaMu.Unlock()
	packet.Put(p)
	return
}

type CloseError struct {
	err error
}

func NewCloseError(err error) CloseError {
	return CloseError{err: err}
}

func (e CloseError) Error() string {
	return e.err.Error()
}
