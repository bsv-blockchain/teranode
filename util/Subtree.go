package util

import "C"
import (
	"crypto/sha256"
	"fmt"
	"math"

	"github.com/TAAL-GmbH/ubsv/stores/blob"
)

type SubTree struct {
	rootHash [32]byte
	treeSize int
	Height   int
	Fees     uint64
	Nodes    [][32]byte
	store    blob.Store
}

// NewTree creates a new SubTree with a fixed height
func NewTree(height int) *SubTree {
	var treeSize = int(math.Pow(2, float64(height))) // 1024 * 1024
	return &SubTree{
		Nodes:    make([][32]byte, 0, treeSize),
		Height:   height,
		treeSize: treeSize,
	}
}

func NewTreeByLeafCount(maxNumberOfLeaves int) *SubTree {
	if !isPowerOfTwo(maxNumberOfLeaves) {
		panic("numberOfLeaves must be a power of two")
	}

	height := math.Ceil(math.Log2(float64(maxNumberOfLeaves)))
	return NewTree(int(height))
}

func (st *SubTree) Size() int {
	return cap(st.Nodes)
}

func (st *SubTree) Length() int {
	return len(st.Nodes)
}

func (st *SubTree) IsComplete() bool {
	return len(st.Nodes) == cap(st.Nodes)
}

func (st *SubTree) ReplaceRootNode(node [32]byte) [32]byte {
	st.Nodes[0] = node
	st.rootHash = [32]byte{} // reset rootHash

	return st.RootHash()
}

func (st *SubTree) AddNode(node [32]byte, fee uint64) error {
	if (len(st.Nodes) + 1) > st.treeSize {
		return fmt.Errorf("subTree is full")
	}

	st.Nodes = append(st.Nodes, node)
	st.rootHash = [32]byte{} // reset rootHash
	st.Fees += fee

	return nil
}

func (st *SubTree) AddNodes(nodes [][32]byte) error {
	if (len(st.Nodes) + len(nodes)) > st.treeSize {
		return fmt.Errorf("subTree is full")
	}

	st.Nodes = append(st.Nodes, nodes...)
	st.rootHash = [32]byte{} // reset rootHash

	return nil
}

func (st *SubTree) RootHash() [32]byte {
	if st.rootHash != [32]byte{} {
		return st.rootHash
	}

	// calculate rootHash
	store, err := st.BuildMerkleTreeStoreFromBytes()
	if err != nil {
		return [32]byte{}
	}

	st.rootHash = store[len(store)-1]

	return st.rootHash
}

func (st *SubTree) Difference(ids txMap) ([][32]byte, error) {
	// return all the ids that are in st.Nodes, but not in ids
	diff := make([][32]byte, 0, 1_000)
	for _, id := range st.Nodes {
		if !ids.Exists(id) {
			diff = append(diff, id)
		}
	}

	//fmt.Printf("diff: %d\n", len(diff))
	//for i := 0; i < len(diff); i++ {
	//	hash, _ := chainhash.NewHash(diff[i][:])
	//	fmt.Printf("%s\n", hash.String())
	//	if i > 10 {
	//		break
	//	}
	//}

	return diff, nil
}

func (st *SubTree) BuildMerkleTreeStoreFromBytes() ([][32]byte, error) {
	// Calculate how many entries are re?n array of that size.
	nextPoT := st.nextPowerOfTwo(len(st.Nodes))
	arraySize := nextPoT*2 - 1
	// we do not include the original nodes in the merkle tree
	merkles := make([][32]byte, arraySize-len(st.Nodes))

	if arraySize == 1 {
		// Handle this Bitcoin exception that the merkle root is the same as the transaction hash if there
		// is only one transaction.
		return st.Nodes, nil
	}

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	offset := nextPoT - len(st.Nodes)
	var hash [32]byte
	var currentMerkle [32]byte
	var currentMerkle1 [32]byte
	for i := 0; i < arraySize-1; i += 2 {
		if i < len(st.Nodes) {
			currentMerkle = st.Nodes[i]
			currentMerkle1 = st.Nodes[i+1]
		} else {
			currentMerkle = merkles[i-len(st.Nodes)]
			currentMerkle1 = merkles[i-len(st.Nodes)+1]
		}

		switch {
		// When there is no left child node, the parent is nil ("") too.
		case currentMerkle == [32]byte{}:
			merkles[offset] = [32]byte{}

		// When there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself.
		case currentMerkle1 == [32]byte{}:
			hash = sha256.Sum256(append(currentMerkle[:], currentMerkle[:]...))
			merkles[offset] = sha256.Sum256(hash[:])

		// The normal case sets the parent node to the double sha256
		// of the concatenation of the left and right children.
		default:
			hash = sha256.Sum256(append(currentMerkle[:], currentMerkle1[:]...))
			merkles[offset] = sha256.Sum256(hash[:])
		}
		offset++
	}

	return merkles, nil
}

func isPowerOfTwo(num int) bool {
	if num <= 0 {
		return false
	}
	return (num & (num - 1)) == 0
}

// nextPowerOfTwo returns the next highest power of two from a given number if
// it is not already a power of two.  This is a helper function used during the
// calculation of a merkle tree.
func (st *SubTree) nextPowerOfTwo(n int) int {
	// Return the number if it's already a power of 2.
	if n&(n-1) == 0 {
		return n
	}

	// Figure out and return the next power of two.
	exponent := uint(math.Log2(float64(n))) + 1
	return 1 << exponent // 2^exponent
}

func (st *SubTree) Serialize() []byte {
	// write rootHash

	// write fees

	// write number of nodes

	// write nodes

	return nil
}

func (st *SubTree) Load([]byte) error {
	// read rootHash

	// read fees

	// read number of nodes

	// read nodes

	// calculate rootHash and compare with given rootHash

	return nil
}
