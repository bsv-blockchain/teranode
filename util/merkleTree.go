package util

import (
	sha256 "crypto/sha256"
	"fmt"
	"math"
	"sync"

	"github.com/libsv/go-bt/v2/chainhash"
)

func GetMerkleProofForCoinbase(subtrees []*Subtree) ([]*chainhash.Hash, error) {
	if len(subtrees) == 0 {
		return nil, fmt.Errorf("no subtrees available")
	}

	merkleProof, err := subtrees[0].GetMerkleProof(0)
	if err != nil {
		return nil, fmt.Errorf("failed creating merkle proof for subtree: %v", err)
	}

	// Create a new tree with the subtreeHashes of the subtrees
	topTree := NewTreeByLeafCount(CeilPowerOfTwo(len(subtrees)))
	for _, subtree := range subtrees {
		err = topTree.AddNode(*subtree.RootHash(), subtree.Fees, subtree.SizeInBytes)
		if err != nil {
			return nil, err
		}
	}

	topMerkleProof, err := topTree.GetMerkleProof(0)
	if err != nil {
		return nil, fmt.Errorf("failed creating merkle proofs for toptree: %v", err)
	}

	return append(merkleProof, topMerkleProof...), nil
}

func BuildMerkleTreeStoreFromBytes(nodes []SubtreeNode) (*[]chainhash.Hash, error) {
	if len(nodes) == 0 {
		return &[]chainhash.Hash{}, nil
	}

	// Calculate how many entries are in an array of that size.
	length := len(nodes)
	nextPoT := NextPowerOfTwo(length)
	arraySize := nextPoT*2 - 1
	// we do not include the original nodes in the merkle tree
	merkles := make([]chainhash.Hash, nextPoT-1)
	//merkles := []byte{MaxSubtreeSize: 0}

	if arraySize == 1 {
		// Handle this Bitcoin exception that the merkle root is the same as the transaction hash if there
		// is only one transaction.
		return &[]chainhash.Hash{nodes[0].Hash}, nil
	}

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	height := int(math.Ceil(math.Log2(float64(length))))
	routineSplitSize := 1024 // should be a power of two

	merkleFrom := 0
	for h := 0; h <= height; h++ {
		merkleTo := merkleFrom + int(math.Pow(2, float64(height-h))) - 1
		if merkleTo-merkleFrom > routineSplitSize {
			var wg sync.WaitGroup
			// if we are calculating a large merkle tree, we can do this in parallel
			for i := merkleFrom; i < merkleTo; i += routineSplitSize {
				wg.Add(1)
				go func(i int) {
					defer wg.Done()
					calcMerkles(nodes, i, Min(i+routineSplitSize, merkleTo), nextPoT, length, merkles)
				}(i)
			}
			wg.Wait()
		} else {
			calcMerkles(nodes, merkleFrom, merkleTo, nextPoT, length, merkles)
		}

		merkleFrom = merkleTo + 1
	}

	return &merkles, nil
}

func calcMerkles(nodes []SubtreeNode, merkleFrom, merkleTo, nextPoT, length int, merkles []chainhash.Hash) {
	var offset int
	var currentMerkle chainhash.Hash
	var currentMerkle1 chainhash.Hash
	for i := merkleFrom; i < merkleTo; i += 2 {
		offset = i / 2

		if i < nextPoT {
			if i >= length {
				currentMerkle = chainhash.Hash{}
			} else {
				currentMerkle = nodes[i].Hash
			}

			if i+1 >= length {
				currentMerkle1 = chainhash.Hash{}
			} else {
				currentMerkle1 = nodes[i+1].Hash
			}
		} else {
			currentMerkle = merkles[i-nextPoT]
			currentMerkle1 = merkles[i-nextPoT+1]
		}

		merkles[offset] = calcMerkle(currentMerkle, currentMerkle1)
	}
}

func calcMerkle(currentMerkle chainhash.Hash, currentMerkle1 chainhash.Hash) [32]byte {
	switch {
	// When there is no left child node, the parent is nil ("") too.
	case currentMerkle.Equal(chainhash.Hash{}):
		return chainhash.Hash{}

	// When there is no right child, the parent is generated by
	// hashing the concatenation of the left child with itself.
	case currentMerkle1.Equal(chainhash.Hash{}):
		shaBytes := [64]byte{}
		copy(shaBytes[0:32], currentMerkle[:])
		copy(shaBytes[32:64], currentMerkle[:])
		hash := sha256.Sum256(shaBytes[:])
		return sha256.Sum256(hash[:])

	// The normal case sets the parent node to the double sha256
	// of the concatenation of the left and right children.
	default:
		shaBytes := [64]byte{}
		copy(shaBytes[0:32], currentMerkle[:])
		copy(shaBytes[32:64], currentMerkle1[:])
		hash := sha256.Sum256(shaBytes[:])
		return sha256.Sum256(hash[:])
	}
}
